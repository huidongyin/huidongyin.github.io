---
title: 消费者-消费者&消费者组
date: 2023-01-01 00:00:00
tags:
  - Kafka
  - 消息队列
categories:
  - Kafka
description: 消费者-消费者&消费者组
toc_number: false
author:
  name: huidong.yin
  link: https://huidongyin.github.io
permalink: /pages/c4ec1b4a-45f6-3fd7-8faf-7af762dfb0ed/
---

应用程序可以通过`KafkaConsumer`来订阅主题，并从订阅的主题中拉取消息。

---

消费者负责订阅kafka中的Topic，并且从订阅的Topic上拉取消息。与其他一些消息中间件不同的是：在kafka的消费理念中还有一层消费组的概念，每个消费者都有一个对应的消费组。当消息发布到Topic后，只会被投递给订阅它的每个消费组中的一个消费者。

![](https://raw.githubusercontent.com/huidongyin/DrawingBed/main/kafka/202311041749594.png)

如上图所示，某个Topic有4个分区，有两个消费组A和B都订阅了这个Topic，消费组A有4个消费者，消费组B有两个消费者。按照Kafka默认的规则，最后的分配结果是消费组A中每一个消费者分配到一个分区，消费组B中每一个消费者分配到两个分区，两个消费组之间互不影响。**每个消费者只能消费到所分配的分区中的消息。或者说：每一个分区只能被一个消费组中的一个消费者所消费。**

当消费组内的消费者个数发生变化时，所对应的分区分配的演变：

假设目前某消费组内只有一个消费者C0，订阅了一个Topic，这个Topic包含7个分区：P0~P6。也就是说，这个消费者C0订阅了7个分区。

此时消费组内又加入一个新的消费者C1，按照既定的逻辑，需要将C0的部分分区分配给消费者C1消费，分配之后C0消费P0到P3,C1消费P4到P6。C0和C1各自负责消费所分配到的分区，彼此之间并无逻辑上的干扰。

紧接着消费组内又加入了一个新的消费者C2，消费者C0和C1将各自消费的部分分区分配给消费者C2，三者各自消费所分配到的分区。

消费者与消费者组这种模型可以让整体的消费能力具备横向伸缩性，可以通过增加或者减少消费者个数来提高或者降低整体的消费能力。对于分区数固定的情况，一味的增加消费者并不会让消费能力一直得到提升，如果消费者过多，出现了消费者的个数大于分区个数的情况，就会有消费者分配不到任何分区。比如一个组内有8个消费者，但是Topic只有7个分区，那么将有一台消费者分配不到任何分区而无法消费任何消息。

以上分配逻辑都是基于默认的分区分配策略进行分析的，可以通过消费者客户端参数`partition.assignment.strategy`
来设置消费者与订阅主题之间的分区分配策略。

对于消息中间件而言，一般有两种消息投递模式:点对点 (P2P，Point-to-Point)模式和发布/订阅 (Pub/Sub)模式。点对点模式是基于队列的，消息生产者发送消息到队列，消息消费者从队列中接收消息。发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题 (Topic)，主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者从主题中订阅消息。主题使得消息的订阅者和发布者互相保持独立，不需要进行接触即可保证消息的传递，发布/订阅模式在消息的一对多广播时采用。Kafka同时支持两种消息投递模式，而这正是得益于消费者与消费组模型的契合:

- 如果所有的消费者都隶属于同一个消费组，那么所有的消息都会被均衡地投递给每一个消费者，即每条消息只会被一个消费者处理，这就相当于点对点模式的应用。
- 如果所有的消费者都隶属于不同的消费组，那么所有的消息都会被广播给所有的消费者，即每条消息会被所有的消费者处理，这就相当于发布/订阅模式的应用。

消费组是一个逻辑上的概念，它将旗下的消费者归为一类，每一个消费者只隶属于一个消费组。每一个消费组都会有一个固定的名称，消费者在进行消费前需要指定其所属消费组的名称，这个可以通过消费者客户端参数`group.id`来配置，默认值为空字符串。

**消费者并非逻辑上的概念，它是实际的应用实例，它可以是一个线程，也可以是一个进程。同一个消费组内的消费者既可以部署在同一台机器上，也可以部署在不同的机器上。**

---
