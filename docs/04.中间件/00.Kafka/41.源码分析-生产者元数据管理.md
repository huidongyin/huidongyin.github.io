---
title: 源码分析-生产者元数据管理
date: 2023-01-01 00:00:00
tags:
    - Kafka
    - 消息队列
categories:
    - Kafka
description: 源码分析-生产者元数据管理
toc_number: false
author:
name: huidong.yin
link: https://huidongyin.github.io
permalink: /pages/676b62dc-9bfc-3306-bd11-65182a3db6b6/

---

## 1.等待获取集群的元数据

上一节在看消息发送源码的时候提到了有一个步骤：通过`waitOnMetadata()`方法等待获取集群的元数据信息，接下来我们先分析一下这个方法。

1. 尝试从元数据缓存获取集群的元数据信息。
2. 检测如果当前topic存在于元数据缓存的无效topic列表，则直接抛出异常。
3. 将topic和消息投递最大等待时间加入元数据。
4. 从集群元数据获取当前topic的分区数。
5. 如果分区数不为空并且[分区编号为空或者分区号小于分区数]，直接返回集群元数据。
6. 开始执行循环，直到满足当前topic的分区数不为空并且[分区编号为空或者分区号小于分区数]。
    1. 将当前topic和当前时间加入到元数据
    2. 请求更新topic信息，这里仅仅修改标记位。
    3. 唤醒Sender线程。
    4. 让当前业务线程阻塞等待。
    5. 等到当前业务线程被唤醒后重新拉取集群元数据。
    6. 重新计算等待元数据耗时，如果超过了消息投递最大等待时间，就抛出超时异常。
    7. 重新计算消息还有多少秒就必须要投递出去，并重新获取topic的分区数。
7. 返回集群元数据。

关于⑤的判断条件和⑥的循环终止条件，**分区数不为空**说明从集群元数据里面找到了这个topic的分区信息，**分区编号为空**说明这条消息没有在外部或者拦截器内指定消息要发送到的目标分区，**分区号小于分区数**说明外部指定了消息要发送到的分区，并且这个分区是合法的。

关于步骤6.5，当前消息发送的业务线程是如何唤醒的呢？下面会具体分析源码，其实是在元数据更新请求的响应解析完成后，会唤醒所有等待元数据更新的线程。

在上一节分析生产者初始化流程的时候我们知道，生产者初始化过程中会初始化生产者的元数据缓存`ProducerMetadata`以及它的父类`Metadata`；接下来在`Metadata`的`bootstrap()`方法里面初始化了`MetadataCache`，也就是实际的元数据缓存，`MetadataCache`和`Cluster`的数据结构在上一篇也已经分析过了，这里不再赘述，接下来我们看一下`MetadataCache`里面的方法。

---

## 2.MetadataCache

`bootstrap()`方法是初始化MetadataCache的方法，首先遍历生产者启动参数配置里面的serverList参数初始化brokerId和broker信息的映射表，这里因为此时不知道具体的brokerId，所以以负数表述brokerId；然后调用MetadataCache的构造函数完成元数据缓存的初始化。

`mergeWith()`方法将新的元数据信息和当前的元数据信息合并，并返回一个新的MetadataCache对象。

1. 根据入参传入的断言型Predicate接口创建一个断言型对象，用于确定是否应该保留特定的主题。
2. 将要添加的分区元数据信息添加到新的分区元数据集合。
3. 遍历原来的分区元数据信息，根据断言对象判断是否需要将原有的分区信息加入到新的分区元数据集合。
4. 将新的未授权的主题信息和原有的未授权的主题信息断言合并，同理合并的还有无效的主题列表，内部主题列表。
5. 通过上面合并后的信息，构建一个新的元数据缓存对象返回。

---

## 3.MetadataUpdater

前面我们在分析生产者启动流程的时候提到过，在生产者启动过程中会通过`newSender()`方法创建一个Sender，这个Sender里面包含了实际消息发送的逻辑，接下来我们看一下`newSender()`方法。这个方法的核心有两点：

1. 创建NetworkClient对象。
2. 调用Sender的构造函数并传入NetworkClient对象创建Sender对象。

再看一下NetworkClient对象创建过程：在他的构造函数里面，创建了一个DefaultMetadataUpdater对象，负责管理元数据的更新。

通过前面的分析我们知道，发送消息的业务线程会在等待获取元数据的时候，唤醒Sender线程然后阻塞自身，直到被Sender线程唤醒；接下来我们来看一下，Sender线程被唤醒后干了什么？

---

## 4.元数据更新请求发送与响应处理

Sender线程的`run()`方法里面判断只要当前线程处于正常运行状态，就会不停地循环调用`runOnce()`方法。`runOnce()`方法首先是创建发送到Kafka集群的请求，然后调用NetworkClient的`poll()`方法执行真正的IO操作将请求发送出去，并处理收到的响应。

NetworkClient的`poll()`方法里面有三个需要我们关心的步骤：

1. 通过MetadataUpdater尝试更新元数据。
2. 通过selector执行IO操作。
3. 处理请求的响应数据。

---

### 4.1 尝试更新元数据

接下来我们先来看一下MetadataUpdater尝试更新元数据的逻辑。

1. 首先计算下一次更新源数据的时间。
2. 检测是否已经发送了元数据更新请求，如果已经发送了，那就重新设置元数据更新请求的超时时间。
3. 计算元数据更新是否超时，未超时则直接返回。
4. 如果需要立即更新，就找出最空闲的broker节点信息。
5. 发送更新元数据的请求。

正常情况下，发送更新元数据的请求，会直接获取最空闲节点的id，然后判断当前节点状态是否可以发送请求，如果可以那就组装元数据请求然后往目标broker发送即可。如果节点状态不正常就判断当前是否正在进行重连，如果也不是就尝试连接节点，如果连不上就只能阻塞等待新的可用节点。

---

### 4.2 处理元数据更新请求的响应

NetworkClient的`poll()`方法里面会处理请求的响应数据，也就是遍历所有收到的响应，判断如果存在MetadataResponse类型的响应，就使用MetadataUpdater对象来处理元数据更新请求的响应。

具体的处理逻辑其实就是判断broker信息是否为空，如果broker信息为空表示没有获得元数据，记录更新失败时间到元数据，否则根据响应信息更新元数据信息。

ProducerMetadata的更新首先会调用Metadata的更新逻辑，然后判断如果新topic集合不为空，那就判断新topic是否出现在元数据请求的响应数据里面了，如果出现那就说明他不算新topic了，直接移除掉；最后唤醒等待元数据的所有业务发送线程。

Metadata的更新会首先修改一些标记位和更新时间等，然后将元数据请求的响应数据解析到生产者客户端的元数据缓存，最后回调所有集群资源监听器的`onUpdate()`方法，处理集群资源变更事件。

---

## 5.总结

总的来说，生产者的元数据信息主要存放在MetadataCache里面，通过Sender线程内部的NetworkClient只有的MetadateUpdater来负责管理更新元数据缓存。当业务线程需要拉取元数据的时候会唤醒Sender线程并阻塞自身，Sender县城北唤醒后会在达到一定条件的时候回选择负载最小的节点发起元数据更新请求，收到节点响应数据以后会更新元数据缓存并唤醒所有等待元数据的业务线程。

![](https://raw.githubusercontent.com/huidongyin/DrawingBed/main/Kafka/202312242219618.png)

---

