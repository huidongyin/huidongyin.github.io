---
title: Zookeeper客户端与核心参数
date: 2023-01-01 00:00:00
tags: 
  - Zookeeper
  - 中间件
categories: 
  - Zookeeper
description: Zookeeper客户端与核心参数
toc_number: false
author:
  name: huidong.yin
  link: https://huidongyin.github.io
permalink: /pages/b4af8eb8-0a51-36d2-845c-2e7d0a5fc536/
---

前面两篇我们讲解了 ZooKeeper 的一些核心概念，也对部分核心概念进行了实战演示，比如节点以及节点类型，这两块我们实战操作了一下，也用到了一些 ZooKeeper Client 的相关 API。

本篇幅我会先讲解以及实操一下原生 zkCli 所支持的命令与语法，然后我会实操下 ZooKeeper 当前最流行的客户端框架 Curator 的核心 API，最后我会讲解几个 ZooKeeper Server 核心参数的含义。

我们先来看第一个内容：**zkCli 的命令语法**。

---

## 1.zkCli操作


>  如何执行 `zkCli`？`zkCli`是一个Zookeeper原生的客户端工具，它的位置在 `Zookeeper/bin`目录下，直接 `sh zkCli.sh`就可以进入。

首先看一下都有哪些命令？


```bash
[zk: localhost:2181(CONNECTED) 0] help
ZooKeeper -server host:port -client-configuration properties-file cmd args
	addWatch [-m mode] path # optional mode is one of [PERSISTENT, PERSISTENT_RECURSIVE] - default is PERSISTENT_RECURSIVE
	addauth scheme auth
	close 
	config [-c] [-w] [-s]
	connect host:port
	create [-s] [-e] [-c] [-t ttl] path [data] [acl]
	delete [-v version] path
	deleteall path [-b batch size]
	delquota [-n|-b|-N|-B] path
	get [-s] [-w] path
	getAcl [-s] path
	getAllChildrenNumber path
	getEphemerals path
	history 
	listquota path
	ls [-s] [-w] [-R] path
	printwatches on|off
	quit 
	reconfig [-s] [-v version] [[-file path] | [-members serverID=host:port1:port2;port3[,...]*]] | [-add serverId=host:port1:port2;port3[,...]]* [-remove serverId[,...]*]
	redo cmdno
	removewatches path [-c|-d|-a] [-l]
	set [-s] [-v version] path data
	setAcl [-s] [-v version] [-R] path acl
	setquota -n|-b|-N|-B val path
	stat [-w] path
	sync path
	version 
	whoami 
Command not found: Command not found help
[zk: localhost:2181(CONNECTED) 1] 

```


当然我们不会逐个讲解，我们只是来看几个常用的。

1. 如何查看版本？

直接使用 `version`命令。

```bash
[zk: localhost:2181(CONNECTED) 1] version
ZooKeeper CLI version: 3.7.1-a2fb57c55f8e59cdd76c34b357ad5181df1258d5, built on 2022-05-07 06:45 UTC
[zk: localhost:2181(CONNECTED) 2] 
```

2. 如何创建一个节点？

使用 `create`命令。

```bash
[zk: localhost:2181(CONNECTED) 2] create -e /xxx
Created /xxx
[zk: localhost:2181(CONNECTED) 3] 
```

3. 如何给节点设置值？

`set/get`命令。

```bash
[zk: localhost:2181(CONNECTED) 3] set /xxx aaa
[zk: localhost:2181(CONNECTED) 4] get /xxx
aaa
[zk: localhost:2181(CONNECTED) 5] 
```

4. 如何删除一个节点？

`delete`命令。

```bash
[zk: localhost:2181(CONNECTED) 5] delete /xxx
[zk: localhost:2181(CONNECTED) 6] ls /
[zookeeper]
[zk: localhost:2181(CONNECTED) 7] 
```

5. 如何查看节点状态？

`stat`命令。

```bash
[zk: localhost:2181(CONNECTED) 7] stat /zookeeper
cZxid = 0x0
ctime = Thu Jan 01 00:00:00 UTC 1970
mZxid = 0x0
mtime = Thu Jan 01 00:00:00 UTC 1970
pZxid = 0x0
cversion = -2
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 0
numChildren = 2
[zk: localhost:2181(CONNECTED) 8] 
```

6. 如何查看节点下有哪些子节点？

`ls`命令。

```bash
[zk: localhost:2181(CONNECTED) 9] ls /
[zookeeper]
[zk: localhost:2181(CONNECTED) 10] 
```

7. 如何查看曾经执行过的命令？

`history`命令。

```bash
[zk: localhost:2181(CONNECTED) 10] history
0 - help
1 - version
2 - create -e /xxx
3 - set /xxx aaa
4 - get /xxx
5 - delete /xxx
6 - ls /
7 - stat /zookeeper
8 - ls
9 - ls /
10 - history
[zk: localhost:2181(CONNECTED) 11] 
```

8. 如何移除一个节点的 `watchers`？

直接使用 `removewatches`命令，如果没有 Watcher，那么会提示 `No such watcher for path`。

```bash
[zk: localhost:2181(CONNECTED) 11] removewatches /zookeeper
KeeperErrorCode = No such watcher for /zookeeper
[zk: localhost:2181(CONNECTED) 12] 
```

> 对应的还有 addWatch，注册监听。

9. 如何正确退出客户端？

`ctrl + c`不会主动通知 ZooKeeper Server，所以它不会立即让临时节点断开连接，只能等到下次心跳的时候发现断连了，才会删除临时节点。而 `quit`是主动通知 ZooKeeper 服务端说要断开连接，会立即删除临时节点。

**ZooKeeper 的客户端命令和 Linux 文件系统的很像，比如 ls、history 这两个命令完全和 Linux 的一样，其他命令也都很简单粗暴，比如 create 是创建、delete 是删除、set/get 是设置/获取值等。**

上面全是命令行操作，那 Java 怎么调用呢？自然是有大佬已经把底层命令封装成框架了，而且是 Java 写的框架： **Curator** 。

---

## 2.Curator操作

我们通过使用 Curator 来完成一个元数据的 CRUD 功能，进而熟悉它的 API 使用。

首先，我们需要集成 maven 坐标：

```xml
        <dependency>
            <groupId>org.apache.curator</groupId>
            <artifactId>curator-framework</artifactId>
            <version>5.5.0</version>
        </dependency>
        <dependency>
            <groupId>org.apache.curator</groupId>
            <artifactId>curator-recipes</artifactId>
            <version>5.5.0</version>
        </dependency>
```

接下来就可以代码操作了：

```java
class CuratorDemoApplicationTests {

    private static final String PATH = "/example/curator";

    private static final String URI = "127.0.0.1:2181,127.0.0.1:2182,127.0.0.1:2183";

    @Test
    void contextLoads() throws Exception {
        //建立curator客户端
        CuratorFramework client = CuratorFrameworkFactory.builder().connectString(URI).sessionTimeoutMs(600000).connectionTimeoutMs(300000).retryPolicy(new ExponentialBackoffRetry(1000, 3)).build();
        //启动curator客户端
        client.start();
        //初始化curator cache
        CuratorCache cache = CuratorCache.build(client, PATH);
        //声明curator cache 监听器
        CuratorCacheListener listener = CuratorCacheListener.builder()
                //节点创建回调
                .forCreates(node -> System.out.printf("===Node created: [%s]%n", node))
                //节点更新回调
                .forChanges((oldNode, node) -> System.out.printf("===Node changed. Old: [%s] New: [%s]%n", oldNode, node))
                //节点删除回调
                .forDeletes(oldNode ->
                        System.out.printf("===Node deleted. Old value: [%s]%n", oldNode))
                //缓存初始化回调
                .forInitialized(() -> System.out.println("===Cache initialized"))
                .build();

        //注册监听器到 curator cache
        cache.listenable().addListener(listener);
        //启动 curator cache
        cache.start();
        String path = PATH + "/huidong";
        //create()创建节点
        //setDate()写数据
        //creatingParentsIfNeeded()父节点不存在则创建
        client.create().orSetData().creatingParentsIfNeeded().forPath(path, new String("aaa").getBytes());
        //getData()获取数据
        byte[] bytes = client.getData().forPath(PATH);
        System.out.println(new String(bytes));
        //getChildren()获取子节点
        List<String> list = client.getChildren().forPath(PATH);
        if (!CollectionUtils.isEmpty(list)) {
            for (String s : list) {
                System.out.println("s:" + s);
            }
        }

        //checkExists()检查是否存在
        System.out.println("client.checkExists().forPath(path) = " + client.checkExists().forPath(path).toString());
        System.out.println("client.getData().forPath(path) = " + new String(client.getData().forPath(path)));
        client.create().orSetData().creatingParentsIfNeeded().forPath(path, new String("bbb").getBytes());
        System.out.println("client.getData().forPath(path) = " + new String(client.getData().forPath(path)));
        //delete()删除节点
        //quietly()用于在删除节点时忽略删除过程中可能抛出的异常
        //deletingChildrenIfNeeded()如果指定节点有子节点，将会同时删除子节点。它用于递归地删除指定路径下的所有子节点及其本身
        client.delete().quietly().deletingChildrenIfNeeded().forPath(path);
        System.out.println("client.checkExists().forPath(path) = " + client.checkExists().forPath(path));
        //关闭curator cache
        cache.close();
        //关闭 curator 客户端
        client.close();
    }

}

```


一些其他的 API 就不演示了，可以看下这个类 `org.apache.curator.framework.CuratorFramework`，这里面包含很多核心 API，而且 API 的命名风格和上面介绍的 `zkCli` 的命令命名很像。

当然它不只是有元数据 CRUD 的功能，它还基于 ZooKeeper 的临时节点特性实现了分布式锁。不光分布式锁，它还封装了选 Leader、Wacther 监听等功能。

接下来我们看一下最后的一块内容：Server 端核心参数有哪些？

---

## 3.Server 端核心参数

这里当然不会列举出全部参数，然后逐个解释，大可不必浪费时间，我只列举出一些，其他想了解的可以去官方看，官方最权威。

先来看第一组参数： **tickTime、initLimit、syncLimit** 。

* `tickTime`：ZooKeeper 服务器与客户端之间的心跳时间间隔。单位是毫秒值。也就是每隔多少毫秒发一次心跳。
* `initLimit `：Leader 与 Follower 之间建立连接后，能容忍同步数据的最长时间，单位是 `n * tickTime `，比如配置的是 `initLimit: 3 `，那就是 Leader 和 Follower 之间同步数据的最大时间是 `3*tickTime`毫秒。假如你的 ZooKeeper 里存储的数据量已经比较大了，那么 Follower 同步数据需要的时间肯定相对较长，此时可以调大这个参数，防止超时断开同步。超时后，此次同步 Leader 就不会管这个 Follower 了。
* `syncLimit`：Leader 和 Follower 之间能容忍的最大请求响应时间，单位是 `n * tickTime `，比如配置的是 `syncLimit: 3 `，那就是 Leader 和 Follower 之间一次请求响应的最大时间是 `3*tickTime `毫秒。如果超过 `3*tickTime`毫秒没有心跳，那么 Leader 就把这个 Follower 给踢出去了，认为这个 Follower 已经挂掉了。

**总结一个重点：initLimit 和 syncLimit 都是以 tickTime 为基准来进行设置，相当于 tickTime 是这三个里面的最小基本单位。**


接下来再看第二组参数： **dataDir、dataLogDir、snapCount** 。

* `dataDir`：存放 ZooKeeper 里的数据快照文件。ZooKeeper 里会存储很多的数据，内存里有一份快照，在磁盘里其实也会有一份数据的快照，用于重启、异常宕机等情况能正常恢复之前的数据。
* `dataLogDir `：存储事务日志。比如：写数据的时候按照 2PC 两阶段提交 `proposal`，然后每台机器都会写入一个本地磁盘的事务日志，这个事务日志就存放在 `dataLogDir`，如果没有显示配置 `dataLogDir`，那么事务日志会存储在 `dataDir` 目录下。
* `snapCount`：多少个事务生成一个快照。默认是 10 万个事务生成一次快照，快照文件存储到 `dataDir` 目录下。

**总结一句话：dataDir 是存放节点数据快照的地方，dataLogDir 是存放写请求两阶段提交所产生的事务日志的地方，如果 dataLogDir 没有配置，那么事务日志默认存放在 dataDir 中。而 snapCount 是决定多少个事务才生成快照文件的。**


再来看看第三组参数： **端口号** 。

我们在搭建 ZooKeeper 集群的时候都会配置两个端口号，比如如下：

```plaintext
server.1=zk1:2888:3888;2181
server.2=zk2:2888:3888;2181
server.3=zk3:2888:3888;2181
```


那为啥是两个端口号呢？这里用通俗的语言解释下。

* 2888 端口：用于 Leader 和 Follower 之间进行数据同步和通信的。
* 3888 端口：用于集群恢复模式的时候进行 Leader 选举投票的，也就是说所有的机器之间进行选举投票的时候都是基于 3888 端口来的。

我们前面已经知道 Leader 和 Follower 之间通信是有超时时间配置的，现在我们又知道 3888 端口是集群内选举投票通信用的，那这个 3888 端口的作用有没有超时时间呢？肯定也是有的～在进行 Leader 选举的时候，各个机器会基于 3888 那个端口建立 TCP 连接，在这个过程中建立 TCP 连接的超时时间可以通过如下参数来设置。

* `cnxTimeout`：5000，毫秒值。

**其实很简单：2888 是 Leader 和其他节点进行数据同步和心跳等通信的，3888是 Leader 挂了后用于机器间通信选举投票的。**


最后再来看几个参数。

一个 Znode 能保存的数据大小是多少呢？这个大小也可以通过如下参数来指定。

* `jute.maxbuffer`：默认是 1mb。也就是 1048575 字节（bytes）。

一台机器上能建立多少个客户端与 ZooKeeper 服务端的连接呢？这个肯定不是无穷大的，也可以通过参数来配置的。

* `maxClientCnxns`：默认是 60 个。假设每次请求都创建一个 ZooKeeper 客户端，跟 ZooKeeper 服务端建立连接、通信、销毁 ZooKeeper 客户端的话，那么如果并发有很多个请求一起连接 ZooKeeper 服务端，此时可能会被 ZooKeeper Server 拒绝的，因为可能超出了限制。

最后一个知识点：我们知道 Follower 无法处理写请求，写请求到 Follower 上的时候会转发到 Leader 去处理，那 Leader 一定要处理吗？能不能拒绝？可以的！

* `leaderServers`：yes。

我们知道中间件大多就配一个可视化页面，也就是管理页面来很直观地统计一些信息，比如：性能、连接数、配置等。可视化页面是前端，底层肯定要去查性能、配置、连接数等项，那怎么查呢？ZooKeeper 也为我们提供了一些运维相关的命令。

---

## 4.运维相关命令



这个就很简单易懂了，我们先列举一下有哪些常用的运维相关命令。

* `conf`：查看配置信息，也就是查 ZooKeeper 的 `zoo.conf` 配置文件。
* `cons`：查看当前 Server 被哪些 Client 连接。
* `crst`：重置客户端的统计信息。
* `srst`：重置 Server 服务端的统计信息。
* `wchs`：查看 Watcher 信息。
* `wchc`：查看 Watcher 的详细信息。
* `wchp`：也是查看 Watcher，但是会按照 znode 进行分组。
* `stat`：查看 Server 运行时状态。
* `mntr`：比上面的 stat 更为强大，`mntr` 的输出比 `stat` 更详细。
* `ruok`：检查服务是否在运行。
* `dump`：输出 `dump` 相关信息。
* `envi`：查看环境变量。

知道了这些命令的含义了，那我们怎么去用呢？很简单，语法 `echo xxx | nc localhost 2181`，比如我们演示几个。

 **先演示一下第一个：查看配置信息（conf）** 。

```bash
root@026536ecbe0c:/apache-zookeeper-3.7.1-bin# echo conf | nc localhost 2181
clientPort=2181
secureClientPort=-1
dataDir=/data/version-2
dataDirSize=201326640
dataLogDir=/datalog/version-2
dataLogSize=612
tickTime=2000
maxClientCnxns=60
minSessionTimeout=4000
maxSessionTimeout=40000
clientPortListenBacklog=-1
serverId=1
initLimit=5
syncLimit=2
electionAlg=3
electionPort=3888
quorumPort=2888
peerType=0
membership: 
server.1=zk1:2888:3888:participant;0.0.0.0:2181
server.2=zk2:2888:3888:participant;0.0.0.0:2181
server.3=zk3:2888:3888:participant;0.0.0.0:2181
version=0root@026536ecbe0c:/apache-zookeeper-3.7.1-bin# 

```



ZooKeeper 的四字命令被配置为仅允许白名单中的命令执行。在 ZooKeeper 的安全配置中，有一个配置项叫做 `4lw.commands.whitelist`，用于定义允许执行的四字命令列表。

默认情况下，大多数命令都是被禁用的，只有一部分命令在白名单中允许执行。在你尝试执行 `conf` 命令时，它被拒绝执行，因为它不在白名单中。

如果需要执行某个四字命令，需要将该命令添加到白名单中。在 ZooKeeper 的配置文件（`zoo.cfg`）中添加或修改 `4lw.commands.whitelist` 配置项，将需要执行的命令加入其中。

例如，要允许执行 `conf` 命令，你可以这样设置：

```plaintext
4lw.commands.whitelist=conf,stat
```

然后重启 ZooKeeper 服务，使配置生效。请谨慎操作白名单配置，确保只允许安全的命令。

---

>  [Zookeeper 官网](https://link.juejin.cn/?target=https%3A%2F%2Fzookeeper.apache.org%2Fdoc%2Fr3.6.0%2FzookeeperCLI.html "https://zookeeper.apache.org/doc/r3.6.0/zookeeperCLI.html")
>
> [Curator 官网](https://link.juejin.cn/?target=https%3A%2F%2Fcurator.apache.org%2F "https://curator.apache.org/")

---
