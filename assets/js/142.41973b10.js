(window.webpackJsonp=window.webpackJsonp||[]).push([[142],{523:function(e,r,t){"use strict";t.r(r);var o=t(4),a=Object(o.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"_1-消息积压计算"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-消息积压计算"}},[e._v("#")]),e._v(" 1.消息积压计算")]),e._v(" "),r("p",[e._v("如图所示，对每一个分区而言，它的Lag等于"),r("code",[e._v("HW-ConsumerOffset")]),e._v("的值，其中ConsumerOffset表示当前的消费位点。")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/Zookeeper/202312162103959.png",alt:""}})]),e._v(" "),r("p",[e._v("以上针对的是普通的情况，如果为消息引入了事务，那么Lag的计算方式会有所不同。如果消费者客户端的"),r("code",[e._v("isolation.level")]),e._v("参数配置为"),r("code",[e._v("read_uncommitted")]),e._v("(默认)，那么Lag的计算方式不受影响；如果这个参数配置为"),r("code",[e._v("read_committed")]),e._v("，那么就要引入LSO来计算了。LSO是LastStableOffset的缩写，如图所示，对未完成的事务而言，LSO的值等于事务中第一条消息的位置，对已经完成的事务而言，他的值同HW相同，所以我们可以得出一个结论："),r("code",[e._v("LSO<=HW<=LEO")]),e._v("。")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/Zookeeper/202312162103432.png",alt:""}})]),e._v(" "),r("p",[e._v("对于分区中有未完成的事务，并且消费者客户端的"),r("code",[e._v("isolation.level")]),e._v("参数配置为"),r("code",[e._v("read_committed")]),e._v("，它对应的Lag等于"),r("code",[e._v("LSO-ConsumerOffset")]),e._v("的值。")]),e._v(" "),r("hr"),e._v(" "),r("h2",{attrs:{id:"_2-同步失效分区"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-同步失效分区"}},[e._v("#")]),e._v(" 2.同步失效分区")]),e._v(" "),r("p",[e._v("消费 Lag 是 Kafka 的普通使用者特别关心的一项指标，而同步失效分区("),r("code",[e._v("under-replicated")]),e._v(")的多少是 Kafka 运维人员非常关心的一项指标。处于同步失效或功能失效(比如处于非活跃状态)的副本统称为失效副本。而包含失效副本的分区也就称为同步失效分区。")]),e._v(" "),r("p",[e._v("通常情况下，在一个运行状况良好的 Kafka 集群中，失效分区的个数应该为 0。Kafka 本身提供了一个相关的指标来表征失效分区的个数，即 UnderReplicatedPartitions，可以通过JMX访问来获取其值，取值范围是大于等于 0 的整数。如果获取的 UnderReplicatedPartitions 值大于 0，那么就需要进一步诊断背后的原因，有可能是某个broker的问题，也有可能引申到整个集群的问题。")]),e._v(" "),r("blockquote",[r("p",[e._v("如果Kafka集群正在做分区重分配，这个值也会大于0。")])]),e._v(" "),r("p",[e._v("如果集群中有多个broker的 UnderReplicatedPartitions 保持一个大于0的稳定值，则一般暗示集群中有broker已经处于下线状态。在这种情况下，这个broker中的分区个数于集群中的所有 UnderReplicatedPartitions （处于下线的broker是不会上报任何指标的）之和是相等的。通常这类问题是由于机器硬件原因引起的，但也有可能是由于操作系统或者JVM引起的，可以往这个方向做进一步的深入调查。")]),e._v(" "),r("p",[e._v("如果集群中存在broker的 UnderReplicatedPartitions 频繁变动，或者处于一个稳定的大于0的值（这里特指没有broker下线的情况）时，一般暗示集群出现了性能问题，通常这类问题很难诊断，不过我们可以进一步将问题缩小，比如先尝试确定这个性能问题是否只存在于集群的某个broker上，还是整个集群上。如果确定集群中所有的 "),r("code",[e._v("under-replicated")]),e._v(" 分区都在单个broker上，那么可以看出这个broker出现了问题，进而可以针对这个单一的broker做专项调查，比如操作系统，GC，网络状态或磁盘状态。")]),e._v(" "),r("p",[e._v("如果多个broker中都出现了 "),r("code",[e._v("under-replicated")]),e._v(" 分区，则一般是整个集群的问题，但也有可能是单个broker出现了问题，前者可以理解，后者是什么意思?如果某个broker在消息同步方面出了问题，那么其上的follower副本就无法及时有效的与其他broker上的leader副本进行同步，这样一来就出现了多个broker都存在 "),r("code",[e._v("under-replicated")]),e._v(" 分区的现象。")]),e._v(" "),r("hr")])}),[],!1,null,null,null);r.default=a.exports}}]);