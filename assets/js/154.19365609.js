(window.webpackJsonp=window.webpackJsonp||[]).push([[154],{535:function(t,_,a){"use strict";a.r(_);var r=a(4),v=Object(r.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"一-rocketmq源码目录结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一-rocketmq源码目录结构"}},[t._v("#")]),t._v(" 一，RocketMQ源码目录结构")]),t._v(" "),_("p",[t._v("RocketMQ源码基于Maven模块的组织结构。\n"),_("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/RocketMQ/202311052146893.png",alt:"image.png"}})]),t._v(" "),_("hr"),t._v(" "),_("h2",{attrs:{id:"二-rocketmq的设计理念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二-rocketmq的设计理念"}},[t._v("#")]),t._v(" 二，RocketMQ的设计理念")]),t._v(" "),_("p",[t._v("RocketMQ设计基于主题的发布与订阅模式，其核心功能包括消息发送，消息存储和消息消费，整体设计追求简单和性能高效。")]),t._v(" "),_("ol",[_("li",[t._v("对于数据一致性的容忍")])]),t._v(" "),_("ul",[_("li",[t._v("NameServer摒弃了业界常用的Zk作为消息管理的注册中心，而是自研实现元数据的管理（topic路由信息等）。从实际需求出发，topic路由信息无需在集群之间保持强一致，而是追求最终一致性，并且可以容忍分钟级别的不一致。正是基于这种特性，RocketMQ的NameServer集群之间互不通信，这样极大的降低了NameServer实现的复杂度，对网络的要求也降低了不少，性能相比zk还有了很大的提升。")])]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[t._v("高效的IO存储机制")])]),t._v(" "),_("ul",[_("li",[t._v("RocketMQ追求消息发送的高吞吐量，RocketMQ的消息存储文件被设计成文件组的概念，组内单个文件大小固定，方便引入内存映射机制，所有主题的消息存储按顺序编写，极大的提升了消息的写性能。同时为了兼顾消息消费与消息查找，引入了消息消费队列文件与索引文件。")])]),t._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[t._v("容忍存在设计缺陷")])]),t._v(" "),_("ul",[_("li",[t._v("适当将某些工作下放给RocketMQ的使用者，只保证消息被消费者消费，在设计上允许消息被重复消费，简化了消息中间件的内核。")])]),t._v(" "),_("hr"),t._v(" "),_("h2",{attrs:{id:"三-设计目标"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三-设计目标"}},[t._v("#")]),t._v(" 三，设计目标")]),t._v(" "),_("h3",{attrs:{id:"_1-架构模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-架构模式"}},[t._v("#")]),t._v(" 1.架构模式")]),t._v(" "),_("p",[t._v("RocketMQ与大部分消息队列一样，采用订阅发布模型，主要组件包括：消息发送者，消息服务器，消息消费和路由发现。")]),t._v(" "),_("hr"),t._v(" "),_("h3",{attrs:{id:"_2-顺序消息"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-顺序消息"}},[t._v("#")]),t._v(" 2.顺序消息")]),t._v(" "),_("p",[t._v("RocketMQ可以严格保证消息有序。")]),t._v(" "),_("hr"),t._v(" "),_("h3",{attrs:{id:"_3-消息过滤"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-消息过滤"}},[t._v("#")]),t._v(" 3.消息过滤")]),t._v(" "),_("p",[t._v("消息过滤指的是在消费消息时，消息消费者可以对同一个Topic下的消息按照规则只消费自己感兴趣的消息。RocketMQ消息过滤是服务端和消费端共同完成的。")]),t._v(" "),_("hr"),t._v(" "),_("h3",{attrs:{id:"_4-消息存储"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-消息存储"}},[t._v("#")]),t._v(" 4.消息存储")]),t._v(" "),_("p",[t._v("消息存储的考量一般有两点："),_("strong",[t._v("消息堆积能力")]),t._v("和"),_("strong",[t._v("消息存储性能")]),t._v("。RocketMQ追求消息存储的高性能，引入内存映射机制，所有主题的消息按顺序存储在同一文件中。同时为了避免消息在消息存储服务器中无限的累积，引入了消息文件过期机制和文件存储空间报警机制。")]),t._v(" "),_("hr"),t._v(" "),_("h3",{attrs:{id:"_5-消息高可用性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-消息高可用性"}},[t._v("#")]),t._v(" 5.消息高可用性")]),t._v(" "),_("p",[t._v("影响消息可靠性的有以下几种情况：")]),t._v(" "),_("ol",[_("li",[t._v("broker异常崩溃。")]),t._v(" "),_("li",[t._v("操作系统崩溃。")]),t._v(" "),_("li",[t._v("机器断电，但是可以立即恢复供电。")]),t._v(" "),_("li",[t._v("机器无法开机。")]),t._v(" "),_("li",[t._v("磁盘损坏。")])]),t._v(" "),_("p",[t._v("对于前三种，RocketMQ在同步刷盘模式下可以确保消息不丢失，异步刷盘模式下会丢失少量消息。后面的两种单点故障，一旦发生，该节点的消息会全部丢失。如果开启了异步复制机制，RocketMQ能保证只丢失少量消息。")]),t._v(" "),_("hr"),t._v(" "),_("h3",{attrs:{id:"_6-消息消费低延迟"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-消息消费低延迟"}},[t._v("#")]),t._v(" 6.消息消费低延迟")]),t._v(" "),_("p",[t._v("RocketMQ在消息不发生堆积时，以长轮训模式实现准实时的消息推送模式。")]),t._v(" "),_("hr"),t._v(" "),_("h3",{attrs:{id:"_7-确保至少被消费一次"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-确保至少被消费一次"}},[t._v("#")]),t._v(" 7.确保至少被消费一次")]),t._v(" "),_("p",[t._v("RocketMQ通过ACK机制确保消息至少被消费一次，因为ACK消息可能会出现丢失的情况，RocketMQ无法做到消息只被消费一次，所以有重复消费的可能。")]),t._v(" "),_("hr"),t._v(" "),_("h3",{attrs:{id:"_8-回溯消息"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-回溯消息"}},[t._v("#")]),t._v(" 8.回溯消息")]),t._v(" "),_("p",[t._v("回溯消息：消息已经被成功消费，但是业务方期望可以重新消费消息。\nRocketMQ支持按照时间向前或向后回溯消息，时间维度可精确到毫秒。")]),t._v(" "),_("hr"),t._v(" "),_("h3",{attrs:{id:"_9-消息堆积"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-消息堆积"}},[t._v("#")]),t._v(" 9.消息堆积")]),t._v(" "),_("p",[t._v("RocketMQ使用磁盘文件存储消息（内存映射机制），并且在物理布局上为多个大小相等的文件组成逻辑文件组，可以无限循环使用。RocketMQ消息存储文件并不是永久存储在消息服务器端的，而是提供了过期机制，默认保留三天。")]),t._v(" "),_("hr"),t._v(" "),_("h3",{attrs:{id:"_10-定时消息"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-定时消息"}},[t._v("#")]),t._v(" 10.定时消息")]),t._v(" "),_("p",[t._v("如果要支持任意精度的定时消息消费，就必须在消息服务端对消息进行排序，这会带来很大的性能损耗，所以RocketMQ不支持任意进度的定时消息，只支持特定延迟级别。")]),t._v(" "),_("hr"),t._v(" "),_("h3",{attrs:{id:"_11-消息重试"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-消息重试"}},[t._v("#")]),t._v(" 11.消息重试")]),t._v(" "),_("p",[t._v("RocketMQ支持消息重试机制。消息重试是指在消息消费如果发生异常，消息中间件支持消息重新投递。")]),t._v(" "),_("hr")])}),[],!1,null,null,null);_.default=v.exports}}]);