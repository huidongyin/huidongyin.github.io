(window.webpackJsonp=window.webpackJsonp||[]).push([[163],{544:function(_,v,t){"use strict";t.r(v);var a=t(4),r=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"_1-为什么要做集群"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-为什么要做集群"}},[_._v("#")]),_._v(" 1.为什么要做集群")]),_._v(" "),v("p",[_._v("集群主要用于实现高可用与负载均衡。")]),_._v(" "),v("p",[_._v("高可用：如果集群中的某些 MQ 服务器不可用，客户端还可以连接到其他 MQ 服务器。")]),_._v(" "),v("p",[_._v("负载均衡：在高并发的场景下，单台 MQ 服务器能处理的消息有限，可以分发给多台 MQ 服务器。")]),_._v(" "),v("p",[_._v("RabbitMQ 有两种集群模式：普通集群模式和镜像队列模式。")]),_._v(" "),v("hr"),_._v(" "),v("h2",{attrs:{id:"_2-rabbitmq-如何支持集群"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-rabbitmq-如何支持集群"}},[_._v("#")]),_._v(" 2.RabbitMQ 如何支持集群")]),_._v(" "),v("p",[_._v("应用做集群，需要面对数据同步和通信的问题。因为 Erlang 天生具备分布式的特性，所以 RabbitMQ 天然支持集群，不需要通过引入 ZK 或者数据库来实现数据同步。")]),_._v(" "),v("p",[_._v("RabbitMQ 通过/var/lib/rabbitmq/.erlang.cookie 来验证身份，需要在所有节点上保持一致。")]),_._v(" "),v("hr"),_._v(" "),v("h2",{attrs:{id:"_3-rabbitmq的节点类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-rabbitmq的节点类型"}},[_._v("#")]),_._v(" 3.rabbitMQ的节点类型")]),_._v(" "),v("p",[_._v("集群有两种节点类型，一种是磁盘节点（Disc Node），一种是内存节点（RAMNode）。")]),_._v(" "),v("p",[_._v("磁盘节点：将元数据（包括队列名字属性、交换机的类型名字属性、绑定、vhost）放在磁盘中。")]),_._v(" "),v("p",[_._v("内存节点：将元数据放在内存中。")]),_._v(" "),v("blockquote",[v("p",[_._v("内存节点会将磁盘节点的地址存放在磁盘（不然重启后就没有办法同步数据了）。如果是持久化的消息，会同时存放在内存和磁盘。")])]),_._v(" "),v("p",[_._v("集群中至少需要一个磁盘节点用来持久化元数据，否则全部内存节点崩溃时，就无从同步元数据。未指定类型的情况下，默认为磁盘节点。")]),_._v(" "),v("p",[_._v("我们一般把应用连接到内存节点（读写快），磁盘节点用来备份。")]),_._v(" "),v("p",[_._v("集群通过 25672 端口两两通信，需要开放防火墙的端口。")]),_._v(" "),v("p",[v("strong",[_._v("RabbitMQ 集群无法搭建在广域网上")])]),_._v(" "),v("p",[v("strong",[_._v("集群的配置步骤")])]),_._v(" "),v("ol",[v("li",[v("p",[_._v("配置 hosts")])]),_._v(" "),v("li",[v("p",[_._v("同步 erlang.cookie")])]),_._v(" "),v("li",[v("p",[_._v("加入集群（join cluster）")])])]),_._v(" "),v("hr"),_._v(" "),v("h2",{attrs:{id:"_4-普通集群"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-普通集群"}},[_._v("#")]),_._v(" 4.普通集群")]),_._v(" "),v("p",[_._v("普通集群模式下，不同的节点之间只会相互同步元数据。")]),_._v(" "),v("p",[_._v("为什么不直接把队列的内容（消息）在所有节点上复制一份？")]),_._v(" "),v("p",[_._v("主要是出于存储和同步数据的网络开销的考虑，如果所有节点都存储相同的数据，就无法达到线性地增加性能和存储容量的目的（堆机器）。")]),_._v(" "),v("p",[_._v("假如生产者连接的是节点 3，要将消息通过交换机 A 路由到队列 1，最终消息还是会转发到节点 1 上存储，因为队列 1 的内容只在节点 1 上。")]),_._v(" "),v("p",[_._v("同理，如果消费者连接是节点 2，要从队列 1 上拉取消息，消息会从节点 1 转发到节点 2。其它节点起到一个路由的作用，类似于指针。")]),_._v(" "),v("p",[_._v("普通集群模式不能保证队列的高可用性，因为队列内容不会复制。如果节点失效将导致相关队列不可用，因此我们需要第二种集群模式。")]),_._v(" "),v("hr"),_._v(" "),v("h2",{attrs:{id:"_5-镜像集群"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-镜像集群"}},[_._v("#")]),_._v(" 5.镜像集群")]),_._v(" "),v("p",[_._v("第二种集群模式叫做镜像队列。")]),_._v(" "),v("p",[_._v("镜像队列模式下，消息内容会在镜像节点间同步，可用性更高。不过也有一定的副作用，系统性能会降低，节点过多的情况下同步的代价比较大。")]),_._v(" "),v("hr"),_._v(" "),v("h2",{attrs:{id:"_6-高可用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-高可用"}},[_._v("#")]),_._v(" 6.高可用")]),_._v(" "),v("p",[_._v("集群搭建成功后，如果有多个内存节点，那么生产者和消费者应该连接到哪个内存节点？如果在我们的代码中根据一定的策略来选择要使用的服务器，那每个地方都要修改，客户端的代码就会出现很多的重复，修改起来也比较麻烦。")]),_._v(" "),v("p",[_._v("所以需要一个负载均衡的组件（例如 HAProxy，LVS，Nignx），由负载的组件来做路由。这个时候，只需要连接到负载组件的 IP 地址就可以了。")]),_._v(" "),v("p",[_._v("负载分为四层负载和七层负载。")]),_._v(" "),v("p",[_._v("四层负载：工作在 OSI 模型的第四层，即传输层（TCP 位于第四层），它是根据 IP端口进行转发（LVS 支持四层负载）。RabbitMQ 是 TCP 的 5672 端口。")]),_._v(" "),v("p",[_._v("（修改报文中目标地址和原地址）")]),_._v(" "),v("p",[_._v("七层负载：工作在第七层，应用层（HTTP 位于第七层）。可以根据请求资源类型分配到后端服务器（Nginx 支持七层负载；HAProxy 支持四层和七层负载）。")]),_._v(" "),v("p",[_._v("（处理请求，代理至服务器）")]),_._v(" "),v("p",[_._v("但是，如果这个负载的组件也挂了呢？")]),_._v(" "),v("p",[_._v("我们应该需要这样一个组件")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("它本身有路由（负载）功能，可以监控集群中节点的状态（比如监控HAProxy），如果某个节点出现异常或者发生故障，就把它剔除掉。")])]),_._v(" "),v("li",[v("p",[_._v("为了提高可用性，它也可以部署多个服务，但是只有一个自动选举出来的 MASTER 服务器（叫做主路由器），通过广播心跳消息实现。")])]),_._v(" "),v("li",[v("p",[_._v("MASTER 服务器对外提供一个虚拟 IP，提供各种网络功能。也就是谁抢占到 VIP，就由谁对外提供网络服务。应用端只需要连接到这一个 IP 就行了。")])])]),_._v(" "),v("p",[_._v("这个协议叫做 VRRP 协议（虚拟路由冗余协议 Virtual Router RedundancyProtocol），这个组件就是 Keepalived，它具有 Load Balance 和 High Availability的功能。")]),_._v(" "),v("hr")])}),[],!1,null,null,null);v.default=r.exports}}]);