(window.webpackJsonp=window.webpackJsonp||[]).push([[145],{526:function(t,v,r){"use strict";r.r(v);var _=r(4),s=Object(_.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[t._v("由于某些原因消息无法被正确地投递，为了确保消息不会被无故地丢弃，一般将其置于一个特殊角色的队列，这个队列一般称为"),v("strong",[t._v("死信队列")]),t._v("。后续分析程序可以通过消费这个死信队列中的内容来分析当时遇到的异常情况，进而可以改善和优化系统。")]),t._v(" "),v("p",[t._v("与死信队列对应的还有一个"),v("strong",[t._v("回退队列")]),t._v("的概念，如果消费者在消费时发生了异常，那么就不会对这一次消费进行确认，进而发生回滚消息的操作之后，消息始终会放在队列的顶部，然后不断被处理和回滚，导致队列陷入死循环。为了解决这个问题，可以为每个队列设置一个回退队列，它和死信队列都是为异常处理提供的一种机制保障。实际情况下，回退队列的角色可以由死信队列和重试队列来扮演。")]),t._v(" "),v("p",[t._v("无论Rabbit MQ中的队列， 还是Kafka中的主题， 其实质上都是消息的载体， 换种角度看待问题可以让我们找到彼此的共通性。我们依然可以把Kafka中的主题看作“队列”， 那么重试队列、死信队列的称谓就可以同延时队列一样沿用下来。")]),t._v(" "),v("p",[t._v("理解死信队列，关键是要理解死信。死信可以看作消费者不能处理收到的消息，也可以看作消费者不想处理收到的消息，还可以看作不符合处理要求的消息。比如消息内包含的消息内容无法被消费者解析，为了确保消息的可靠性而不被随意丢弃，故将其投递到死信队列中，这里的死信就可以看作消费者不能处理的消息。再比如超过既定的重试次数之后将消息投入死信队列，这里就可以将死信看作不符合处理要求的消息。")]),t._v(" "),v("p",[t._v("至于死信队列到底怎么用， 是从broker端存入死信队列， 还是从消费端存入死信队列， 需要先思考两个问题：死信有什么用?为什么用?从而引发怎么用。在Rabbit MQ中， 死信一般通过broker端存入， 而在Kafka中原本并无死信的概念， 所以当需要封装这一层概念的时候，就可以脱离既定思维的束缚，根据应用情况选择合适的实现方式，理解死信的本质进而懂得如何去实现死信队列的功能。")]),t._v(" "),v("p",[t._v("重试队列其实可以看作一种回退队列，具体指消费端消费消息失败时，为了防止消息无故丢失而重新将消息回滚到broker中。与回退队列不同的是， 重试队列一般分成多个重试等级，每个重试等级一般也会设置重新投递延时，重试次数越多投递延时就越大。举个例子：消息第一次消费失败入重试队列Q1，Q1的重新投递延时为5s，5s过后重新投递该消息；如果消息再次消费失败则入重试队列Q2，Q2的重新投递延时为10s，10s过后再次投递该消息。以此类推，重试越多次重新投递的时间就越久，为此还需要设置一个上限，超过投递次数就进入死信队列。重试队列与延时队列有相同的地方，都需要设置延时级别。它们的区别是：延时队列动作由内部触发，重试队列动作由外部消费端触发；延时队列作用一次，而重试队列的作用范围会向后传递。")]),t._v(" "),v("p",[t._v("可以在生产者客户端和消费者客户端根据Topic的ACK上报Topic的生产记录和消费记录，消费者每次拉取一批消息然后直接提交消费位点，即使消费者服务异常宕机，由于生产记录和消费记录还在，丢失的消息还可以重试，确保消息至少被消费一次。")]),t._v(" "),v("p",[t._v("同样的，对于消息重试，仍然是在SDK上报生产和消费记录时，附带状态信息，server端根据上报的记录状态决定是不是要重试。")]),t._v(" "),v("hr")])}),[],!1,null,null,null);v.default=s.exports}}]);