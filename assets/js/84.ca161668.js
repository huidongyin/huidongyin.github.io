(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{426:function(t,_,a){"use strict";a.r(_);var v=a(4),i=Object(v.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("p",[t._v("写在前面：MyBatis全文代码git地址："),_("a",{attrs:{href:"https://gitee.com/yin_huidong/mybatis-use.git",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://gitee.com/yin_huidong/mybatis-use.git"),_("OutboundLink")],1)]),t._v(" "),_("p",[t._v("持久层技术的解决方案：")]),t._v(" "),_("ol",[_("li",[t._v("JDBC")]),t._v(" "),_("li",[t._v("Spring的JdbcTemplate")]),t._v(" "),_("li",[t._v("Apache的DbUtils")])]),t._v(" "),_("p",[t._v("以上都不是框架，JDBC是规范，Spring的JdbcTemplate和Apache的DBUtils都只是工具类。")]),t._v(" "),_("p",[t._v("MyBatis概述：\n一个用Java编写的持久层框架，封装了JDBC操作的很多细节，是开发者只需要关注SQL语句本身，不需要关注整个请求过程。")]),t._v(" "),_("p",[t._v("ORM：Object Relational Mappging 对象关系映射。简单的说：就是把数据库表和实体类及实体类的属性对应起来，让我们可以操作实体类就实现操作数据库表。")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("t_user")]),t._v(" "),_("th",[t._v("TUser")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("id")]),t._v(" "),_("td",[t._v("id")])]),t._v(" "),_("tr",[_("td",[t._v("name")]),t._v(" "),_("td",[t._v("name")])])])]),t._v(" "),_("hr"),t._v(" "),_("h2",{attrs:{id:"_1-mybatis环境搭建"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-mybatis环境搭建"}},[t._v("#")]),t._v(" 1.mybatis环境搭建")]),t._v(" "),_("ol",[_("li",[t._v("创建maven工程，导入坐标")]),t._v(" "),_("li",[t._v("创建实体类和mapper接口")]),t._v(" "),_("li",[t._v("创建mybatis的主配置文件和日志文件")]),t._v(" "),_("li",[t._v("创建映射配置文件")])]),t._v(" "),_("hr"),t._v(" "),_("h2",{attrs:{id:"_2-注意事项"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-注意事项"}},[t._v("#")]),t._v(" 2.注意事项")]),t._v(" "),_("ol",[_("li",[t._v("在idea中创建目录的时候，它和包是不一样的。\n"),_("ul",[_("li",[t._v("包在创建时：com.itheima.dao它是三级结构")]),t._v(" "),_("li",[t._v("目录在创建时：com.itheima.dao是一级目录")])])]),t._v(" "),_("li",[t._v("mybatis的映射配置文件位置必须和dao接口的包结构相同")]),t._v(" "),_("li",[t._v("映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名")]),t._v(" "),_("li",[t._v("映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名")])]),t._v(" "),_("hr"),t._v(" "),_("h2",{attrs:{id:"_3-基于xml形式的配置"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-基于xml形式的配置"}},[t._v("#")]),t._v(" 3.基于XML形式的配置")]),t._v(" "),_("p",[t._v("代码：mybatis-01")]),t._v(" "),_("hr"),t._v(" "),_("h2",{attrs:{id:"_4-基于注解形式的配置"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-基于注解形式的配置"}},[t._v("#")]),t._v(" 4.基于注解形式的配置")]),t._v(" "),_("p",[t._v("代码：mybatis-02")]),t._v(" "),_("hr"),t._v(" "),_("h2",{attrs:{id:"_5-思考自己实现mybatis框架"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-思考自己实现mybatis框架"}},[t._v("#")]),t._v(" 5.思考自己实现mybatis框架")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/MyBatis/202311060801864.png",alt:"image.png"}}),t._v(" "),_("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/MyBatis/202311060802420.png",alt:"image.png"}})]),t._v(" "),_("hr"),t._v(" "),_("h3",{attrs:{id:"_5-1-需求分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-需求分析"}},[t._v("#")]),t._v(" 5.1 需求分析")]),t._v(" "),_("ol",[_("li",[t._v("它需要实现对连接资源的自动管理，也就是把创建 Connection、Statement、关闭 Connection、Statement、ResultSet 这些操作封装到底层的对象中，不需要在应用层手动调用。")]),t._v(" "),_("li",[t._v("它需要把 SQL 语句抽离出来实现集中管理，开发人员不用在业务代码里面写 SQL语句。")]),t._v(" "),_("li",[t._v("它需要实现对结果集的转换，也就是我们指定了映射规则之后，这个框架会自动帮我们把 ResultSet 映射成实体类对象。")]),t._v(" "),_("li",[t._v("需要提供一个 API 来给我们操作数据库，这里面封装了对数据库的操作的常用的方法。")])]),t._v(" "),_("hr"),t._v(" "),_("h3",{attrs:{id:"_5-2-概要设计"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-概要设计"}},[t._v("#")]),t._v(" 5.2 概要设计")]),t._v(" "),_("h4",{attrs:{id:"_1-核心对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-核心对象"}},[t._v("#")]),t._v(" ① 核心对象")]),t._v(" "),_("ol",[_("li",[t._v("存放参数和结果映射关系、存放 SQL 语句，我们需要定义一个配置类")]),t._v(" "),_("li",[t._v("执行对数据库的操作，处理参数和结果集的映射，创建和释放资源，我们需要定义一个执行器")]),t._v(" "),_("li",[t._v("有了这个执行器以后，我们不能直接调用它，而是定义一个给应用层使用的 API，它可以根据 SQL 的 id 找到 SQL 语句，交给执行器执行")]),t._v(" "),_("li",[t._v("直接使用 id 查找 SQL 语句太麻烦了，我们干脆把存放 SQL 的命名空间定义成一个接口，把 SQL 的 id 定义成方法，这样只要调用接口方法就可以找到要执行的 SQL。这个时候我们需要引入一个代理类。")])]),t._v(" "),_("hr"),t._v(" "),_("h4",{attrs:{id:"_2-流程分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-流程分析"}},[t._v("#")]),t._v(" ② 流程分析")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/MyBatis/202311060802493.jpeg",alt:"流程分析.jpg"}})]),t._v(" "),_("ol",[_("li",[t._v("定义接口 Mapper 和方法，用来调用数据库操作。Mapper 接口操作数据库需要通过代理类。")]),t._v(" "),_("li",[t._v("定义配置类对象 Configuration。")]),t._v(" "),_("li",[t._v("定义应用层的 API SqlSession。它有一个 getMapper()方法，我们会从配置类Configuration 里面使用 Proxy.newProxyInatance()拿到一个代理对象 MapperProxy。")]),t._v(" "),_("li",[t._v("有了代理对象 MapperProxy 之后，我们调用接口的任意方法，就是调用代理对象的 invoke()方法。")]),t._v(" "),_("li",[t._v("代理对象 MapperProxy 的 invoke()方法调用了 SqlSession 的 selectOne()。")]),t._v(" "),_("li",[t._v("SqlSession 只是一个 API，还不是真正的 SQL 执行者，所以接下来会调用执行器 Executor 的 query()方法。")]),t._v(" "),_("li",[t._v("执行器 Executor 的 query()方法里面就是对 JDBC 底层的 Statement 的封装，最终实现对数据库的操作，和结果的返回。")])]),t._v(" "),_("hr"),t._v(" "),_("h3",{attrs:{id:"_5-3-代码-思考"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-代码-思考"}},[t._v("#")]),t._v(" 5.3 代码&思考")]),t._v(" "),_("p",[t._v("mybatis-0")]),t._v(" "),_("ol",[_("li",[t._v("在 Executor 中，对参数、语句和结果集的处理是耦合的，没有实现职责分离；")]),t._v(" "),_("li",[t._v("参数：没有实现对语句的预编译，只有简单的格式化（format），效率不高，还存在 SQL 注入的风险；")]),t._v(" "),_("li",[t._v("语句执行：数据库连接硬编码；")]),t._v(" "),_("li",[t._v("结果集：还只能处理 Blog 类型，没有实现根据实体类自动映射。确实有点搓，拿不出手。")])]),t._v(" "),_("p",[_("strong",[t._v("展望")])]),t._v(" "),_("ol",[_("li",[t._v("支持参数预编译")]),t._v(" "),_("li",[t._v("支持结果集的自动处理（通过反射）")]),t._v(" "),_("li",[t._v("对 Executor 的职责进行细化")]),t._v(" "),_("li",[t._v("在方法上使用注解配置 SQL")]),t._v(" "),_("li",[t._v("查询带缓存功能")]),t._v(" "),_("li",[t._v("支持自定义插件")])]),t._v(" "),_("hr"),t._v(" "),_("h2",{attrs:{id:"_6-mybatis与jdbc编程比较"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-mybatis与jdbc编程比较"}},[t._v("#")]),t._v(" 6.Mybatis与jdbc编程比较")]),t._v(" "),_("ol",[_("li",[t._v("数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。")])]),t._v(" "),_("blockquote",[_("p",[t._v("解决：在 SqlMapConfig.xml 中配置数据链接池，使用连接池管理数据库链接。")])]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[t._v("Sql 语句写在代码中造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java 代码。")])]),t._v(" "),_("blockquote",[_("p",[t._v("解决：将 Sql 语句配置在 XXXXmapper.xml 文件中与 java 代码分离。")])]),t._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[t._v("向 sql 语句传参数麻烦，因为 sql 语句的 where 条件不一定，可能多也可能少，占位符需要和参数对应。")])]),t._v(" "),_("blockquote",[_("p",[t._v("解决：Mybatis 自动将 java 对象映射至 sql 语句，通过 statement 中的 parameterType 定义输入参数的类型。")])]),t._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[t._v("对结果集解析麻烦，sql 变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成 pojo 对象解析比较方便。")])]),t._v(" "),_("blockquote",[_("p",[t._v("解决：Mybatis 自动将 sql 执行结果映射至 java 对象，通过 statement 中的 resultType 定义输出结果的类型")])]),t._v(" "),_("hr")])}),[],!1,null,null,null);_.default=i.exports}}]);