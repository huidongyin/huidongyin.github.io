(window.webpackJsonp=window.webpackJsonp||[]).push([[162],{543:function(a,s,t){"use strict";t.r(s);var e=t(4),r=Object(e.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"_1-服务端流控"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-服务端流控"}},[a._v("#")]),a._v(" 1.服务端流控")]),a._v(" "),s("p",[a._v("当生产 MQ 消息的速度远大于消费消息的速度时，会产生大量的消息堆积，占用系统资源，导致机器的性能下降。我们想要控制服务端接收的消息的数量，应该怎么做呢？")]),a._v(" "),s("hr"),a._v(" "),s("h3",{attrs:{id:"_1-1设置队列长度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1设置队列长度"}},[a._v("#")]),a._v(" 1.1设置队列长度")]),a._v(" "),s("p",[a._v("队列有两个控制长度的属性")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("x-max-length：队列中最大存储最大消息数，超过这个数量，队头的消息会被丢弃。\nx-max-length-bytes：队列中存储的最大消息容量（单位 bytes），超过这个容量，队头的消息会被丢弃。\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("p",[a._v("设置队列长度只在消息堆积的情况下有意义，而且会删除先入队的消息，不能真正地实现服务端限流。")]),a._v(" "),s("hr"),a._v(" "),s("h3",{attrs:{id:"_1-2-内存控制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-内存控制"}},[a._v("#")]),a._v(" 1.2.内存控制")]),a._v(" "),s("p",[a._v("RabbitMQ 会在启动时检测机器的物理内存数值。默认当 MQ 占用 40% 以上内存时，MQ 会主动抛出一个内存警告并阻塞所有连接。可以通过修改rabbitmq.config 文件来调整内存阈值，默认值是 0.4。")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("[{rabbit, [{vm_memory_high_watermark, 0.4}]}]\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("也可以用命令动态设置，如果设置成 0，则所有的消息都不能发布。")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("rabbitmqctl set_vm_memory_high_watermark 0.3\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("hr"),a._v(" "),s("h3",{attrs:{id:"_1-3磁盘控制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3磁盘控制"}},[a._v("#")]),a._v(" 1.3磁盘控制")]),a._v(" "),s("p",[a._v("通过磁盘来控制消息的发布。当磁盘空间低于指定的值时（默认50MB），触发流控措施。")]),a._v(" "),s("p",[a._v("例如：指定为磁盘的 30%或者 2GB")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("disk_free_limit.relative = 3.0\ndisk_free_limit.absolute = 2GB\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("hr"),a._v(" "),s("h2",{attrs:{id:"_2-消费端限流"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-消费端限流"}},[a._v("#")]),a._v(" 2.消费端限流")]),a._v(" "),s("h3",{attrs:{id:"_2-1官网描述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1官网描述"}},[a._v("#")]),a._v(" 2.1官网描述")]),a._v(" "),s("p",[a._v("默认情况下，如果不进行配置，RabbitMQ 会尽可能快速地把队列中的消息发送到消费者。因为消费者会在本地缓存消息，如果消息数量过多，可能会导致 OOM 或者影响其他进程的正常运行。")]),a._v(" "),s("p",[a._v("在消费者处理消息的能力有限，例如消费者数量太少，或者单条消息的处理时间过长的情况下，如果我们希望在一定数量的消息消费完之前，不再推送消息过来，就要用到消费端的流量限制措施。")]),a._v(" "),s("p",[s("strong",[a._v("可以基于 Consumer 或者 channel 设置 prefetch count 的值，含义为 Consumer端的最大的 unacked messages 数目。当超过这个数值的消息未被确认，RabbitMQ 会停止投递新的消息给该消费者。")])]),a._v(" "),s("hr"),a._v(" "),s("h3",{attrs:{id:"_2-2代码配置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2代码配置"}},[a._v("#")]),a._v(" 2.2代码配置")]),a._v(" "),s("h4",{attrs:{id:"_1-rabbitmq"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-rabbitmq"}},[a._v("#")]),a._v(" 1）RabbitMQ")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v("\tchannel"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("basicQos")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 如果超过 2 条消息没有发送 ACK，当前消费者不再接受队列消息")]),a._v("\n\tchannel"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("basicConsume")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("QUEUE_NAME")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" consumer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("p",[a._v("SimpleMessageListenerContainer")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v("container"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("setPrefetchCount")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("hr"),a._v(" "),s("h4",{attrs:{id:"_2-spring-boot-配置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-spring-boot-配置"}},[a._v("#")]),a._v(" 2）Spring Boot 配置")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("spring.rabbitmq.listener.simple.prefetch=2\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("channel 的 prefetch count 设置为 5。当消费者有 5 条消息没有给 Broker 发送 ACK后，RabbitMQ 不再给这个消费者投递消息。")]),a._v(" "),s("hr"),a._v(" "),s("h2",{attrs:{id:"_3-消息积压-丢失"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-消息积压-丢失"}},[a._v("#")]),a._v(" 3.消息积压，丢失")]),a._v(" "),s("p",[a._v("生产环境中，如果消息在队列和交换机发生积压，并已经开始丢失，应该怎么处理？")]),a._v(" "),s("p",[a._v("临时扩容消费者，先保证现有的业务逻辑，丢失的消息，等待流量高峰期过后，利用程序排查出来，重新灌入MQ队列。也可以考虑将消息临时写入到一个新的topic里，缓解原本的队列压力。")]),a._v(" "),s("p",[a._v("其实还有broker，消息都是存磁盘，但是MQ高吞吐量一个很重要的原因是利用了page Cache ，数据量没特别大的情况下，mq发消息到broker磁盘，此时broker的page cache 中其实也是有这份消息的，当生产者正常消费时，大概率是直接可以从page cache 中拉消息，这个速度是内存级别，page cache没有拉到消息采取磁盘，当消息堆积在broker时，说明生产者生产速度过快，消费者消费不过来，这时broker的page cache被大量的更新，导致消费者拉消息都是去磁盘去读取，page cache失效了，所以扩容消费者数量有用，但是还需要扩容broker的数量。")]),a._v(" "),s("hr")])}),[],!1,null,null,null);s.default=r.exports}}]);