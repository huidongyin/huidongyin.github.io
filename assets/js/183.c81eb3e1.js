(window.webpackJsonp=window.webpackJsonp||[]).push([[183],{564:function(t,a,e){"use strict";e.r(a);var n=e(4),s=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("在数字时代，数据的爆炸性增长催生了对高效信息检索的迫切需求。Elasticsearch（ES）作为一款领先的分布式搜索和分析引擎，为我们提供了强大的数据搜索能力。然而，这背后隐藏着一系列精密的技术，其中底层的正排索引和倒排索引机制扮演着至关重要的角色。本文将深入探讨ES 7.x版本中正排索引和倒排索引的核心原理，为您揭示其在实现高效数据检索方面的不可或缺性。")]),t._v(" "),a("p",[t._v("索引的本质其实就是加快检索数据的存储结构，就像字典的目录，帮助我们快速定位某一个字的页数。ElasticSearch通过"),a("strong",[t._v("正排索引")]),t._v("和"),a("strong",[t._v("倒排索引")]),t._v("来为其高效的数据检索能力赋能。")]),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"_1-正排索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-正排索引"}},[t._v("#")]),t._v(" 1.正排索引")]),t._v(" "),a("p",[t._v("正排索引是一种关联关系的索引机制，类似于图书馆管理员根据书名来查找书籍位置的过程。想象一下，你是一位图书馆管理员，当顾客A输入书名时，系统根据这个书名查找对应的图书位置，并将其返回给顾客。在这个过程中，书名充当了唯一的标识符（类似唯一ID），而图书位置则是实际的数值。为了高效地存储和检索这种关联关系，我们可以使用类似哈希表的结构，这使得信息检索的复杂度可以在O(1)的时间内完成，从而实现高效率的数据访问。正是这种将唯一标识指向实体数值的索引方式，被称为正排索引。")]),t._v(" "),a("p",[t._v("在现实中，MySQL等常见数据库也广泛使用了正排索引的概念，实现了高效的数据检索。")]),t._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("user")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'huidong yin'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("上面这条SQL，哪些数据结构可以满足这样的查询呢？通常正排索引的数据结构主要有三种，Hash表，有序数组，B+Tree。")]),t._v(" "),a("blockquote",[a("p",[t._v("MySQL里面就使用了B+Tree，Hash 表。")])]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"_1-1-哈希表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-哈希表"}},[t._v("#")]),t._v(" 1.1 哈希表")]),t._v(" "),a("p",[t._v("哈希表是一种高效的键值对存储数据结构，能够快速通过键（key）获取相应的值（value），其操作时间复杂度为O(1)。")]),t._v(" "),a("p",[t._v("在哈希表中，通过哈希函数将键转化为唯一的数值，并将对应的值存储在数组的特定位置。当发生哈希冲突时，可以将相应位置构建为链表，将多个值以链表形式存储在同一位置，这时可以将新的值插入链表的头或尾部。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/elasticsearch/202311042125471.png",alt:"image.png"}})]),t._v(" "),a("p",[t._v("需要注意的是，"),a("strong",[t._v("经过哈希算法计算后的键是无法进行排序的，因此哈希表结构并不适用于范围查询等需要排序的情形")]),t._v("。然而，哈希表在等值查询等场景中表现出色，具备优异的性能。")]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"_1-2-有序数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-有序数组"}},[t._v("#")]),t._v(" 1.2 有序数组")]),t._v(" "),a("p",[t._v("有序数组以其自身数据有序的特点，采用二分查找方式，时间复杂度为O(log(N))，在等值查询和范围查询等操作上表现优异。然而，有序数组在数据插入方面存在一定成本，因为为了维护有序性，插入元素后需要移动插入位置之后的所有元素。因此，"),a("strong",[t._v("有序数组适合用于静态数据存储场景")]),t._v("，其中数据变化频率较低。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/elasticsearch/202311042126569.png",alt:"image.png"}})]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"_1-3-b-tree"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-b-tree"}},[t._v("#")]),t._v(" 1.3 B+Tree")]),t._v(" "),a("p",[t._v("B+Tree又叫多路平衡二叉树，是MySQl InnoDB索引底层实现的数据结构，他一定程度上解决了有序数组插入数据时的低效，也解决了哈希表无法进行范围查询的问题，并且B+Tree非常适合在内存，磁盘上存储和访问。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/elasticsearch/202311042126368.png",alt:"image.png"}})]),t._v(" "),a("p",[t._v("在InnoDB存储引擎中，每个节点被构造为一页，页的大小为16KB。这些页面负责存储ID信息，而具体的数据则保存在位于底层的链表中。举例来说，如果ID采用int类型，占用4字节，那么一个页面大约可以容纳4KB / 4B = 1024个ID。B+树的高度会影响其能够存储的数据量，因为在B+树中，树的高度决定了索引查找的代价。通常情况下，一个B+树的高度越低，查找数据的代价就越低，性能越好。这种结构下，树的高度为4，其中除了叶子节点外，每个层级的节点数是上一层级节点数的1/1024倍，即：1 / (1024 ^ 3)。所以，总数据量 ≈ 叶子节点数 * 每个叶子节点容纳的ID数量 ≈ 1024 ^ 3 * 1024 ≈ 1,073,741,824，约等于10亿多一点。意味着我们能够有效地存储超过10亿的数据。")]),t._v(" "),a("p",[t._v("此外，值得注意的是，B+树的第一层和第二层很有可能存在于内存中，因为这些层通常会被频繁访问并被保存在页缓存中。一旦确定数据位于哪个页面，就会将该页面加载到内存中。由于页面内的数据是有序的，所以我们可以利用二分查找方法高效地获取页面内的数据。这种卓越的性能使得B+树在数据库领域中占据着显赫的地位。")]),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"_2-倒排索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-倒排索引"}},[t._v("#")]),t._v(" 2.倒排索引")]),t._v(" "),a("p",[t._v('正排索引是实体ID到实体内容的映射，通过它可以快速定位图书位置。然而，若有顾客提及"有能力的人从不抱怨大环境"，希望找到相关书籍，传统正排索引表无法满足此复杂需求。然而，通过将图书内容进行分词并建立词语到图书名的映射，我们便能满足用户对特定内容的搜索需求。这种扩展索引结构使搜索系统更具适应性和灵活性。')]),t._v(" "),a("p",[t._v("正排索引：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("书名")]),t._v(" "),a("th",[t._v("书内容")]),t._v(" "),a("th",[t._v("书位置")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("摆烂")]),t._v(" "),a("td",[t._v("有能力的人从不抱怨大环境")]),t._v(" "),a("td",[t._v("[2,4,6]")])]),t._v(" "),a("tr",[a("td",[t._v("躺平")]),t._v(" "),a("td",[t._v("劝你吃苦的人都在享受")]),t._v(" "),a("td",[t._v("[3,7,8]")])])])]),t._v(" "),a("p",[t._v("倒排索引：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("短语")]),t._v(" "),a("th",[t._v("书名")]),t._v(" "),a("th",[t._v("数量")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("能力")]),t._v(" "),a("td",[t._v("摆烂")]),t._v(" "),a("td",[t._v("1")])]),t._v(" "),a("tr",[a("td",[t._v("吃苦")]),t._v(" "),a("td",[t._v("躺平")]),t._v(" "),a("td",[t._v("1")])])])]),t._v(" "),a("p",[a("strong",[t._v("分词后将词项与实体ID关联的索引称为倒排索引")]),t._v("。通过倒排索引，我们能够检索出与词项相关的书名。当涉及多个词项时，我们会得到多个列表，将其交集求解。通过这些交集得到的书名列表，我们再根据正排索引定位相应的位置，满足了第二位顾客的需求。")]),t._v(" "),a("p",[t._v("此外，在上述倒排索引表中，除了记录词项与书名的对应关系，还需存储词项在书本中出现的具体位置。这一步是为了应对许多检索场景，需判断关键词前后内容是否符合搜索需求。")]),t._v(" "),a("p",[t._v("倒排索引可以采用哈希表来实现，以实现O(1)的查询复杂度。然而，现实中数据量通常巨大，简单地用哈希表实现倒排索引并不切实可行。面对海量数据，系统会面临以下问题：")]),t._v(" "),a("ol",[a("li",[t._v("分词生成的词项（term）可能庞大，需要高效存储在内存和磁盘上；")]),t._v(" "),a("li",[t._v("如何快速查找对应的词项也是挑战；")]),t._v(" "),a("li",[t._v("每个词项可能对应大量文档，导致文档列表链表变得很长；")]),t._v(" "),a("li",[t._v("在词项对应文档众多情况下，高效进行多个文档列表的交集操作成为难题。")])]),t._v(" "),a("p",[t._v("这四个问题可以归结为两个方面："),a("strong",[t._v("词项问题")]),t._v("和"),a("strong",[t._v("文档列表问题")]),t._v("。在Lucene的倒排索引实现中，通过采用词项索引（Term Index）来解决问题1和问题2。至于问题3和问题4，Lucene采用了Roaring Bitmaps、跳表等技术进行数据压缩和快速交集运算。在处理海量数据时，系统设计通常复杂且精心构思。接下来，我们将深入分析倒排索引的实现，并探讨这些问题是如何被巧妙解决的。")]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"_2-1-总体结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-总体结构"}},[t._v("#")]),t._v(" 2.1 总体结构")]),t._v(" "),a("p",[t._v("倒排索引主要由三个关键部分构成："),a("strong",[t._v("Term Index（词项索引）、Term Dictionary（词项字典）和Posting List（倒排列表）")]),t._v("。其中，Term Dictionary保存词项，随着词项数量的增加，从字典中查找词项的速度可能变慢，为了解决这一问题，引入了Term Index。Term Index作为Term Dictionary的索引，它的设计应"),a("strong",[t._v("尽量紧凑，以便在内存中高效缓存")]),t._v("。而Posting List则存储了每个词项对应的文档ID列表（实际上还包含其他信息，但在这里为了简化说明仅显示ID）。\n"),a("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/elasticsearch/202311042126954.png",alt:"image.png"}}),t._v("\n在深入研究Term Index、Term Dictionary、Posting List的实现细节之前，我们需要先了解Segment、文档、Field和Term之间的关系。在默认情况下，Elasticsearch（ES）每秒都将缓存中的数据写入Segment中，然后按照特定规则将数据刷写到磁盘，并在需要时对这些Segment进行合并。因此，一旦数据写入Segment，其内容将保持不变。这种不变性的设计考虑了两个主要因素：首先，频繁更新对于磁盘的负担较重；其次，可变数据可能引发并发写入的问题。")]),t._v(" "),a("p",[t._v("在逻辑上，一个Segment可以容纳多个文档，而每个文档则包含了多个字段（Field）。就如下图所示，一个Segment中包含了文档1和文档2，而每个文档则各自拥有两个字段。这些字段的内容会经过分词器处理，产生多个Term，而这些Term会被以块的形式保存在Term Dictionary中。此外，系统还会对Term Dictionary的内容建立索引，形成Term Index。")]),t._v(" "),a("p",[t._v("在进行搜索操作时，首先通过Term Index定位到相应的块（Block），然后在该块中进一步找到Term对应的Posting List，其中存储着与Term相关的文档ID。通过这个过程，系统能够计算出满足条件的文档ID列表，并将其返回给用户。")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("Segment 中的每个字段（Field）都会有自己的 Term Index、Term Dictionary、Posting List 结构，也就是说在每个 Field 中这些结构都是独立的")]),t._v("！")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/elasticsearch/202311042127479.png",alt:"未命名文件.png"}})]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"_2-2-term-index"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-term-index"}},[t._v("#")]),t._v(" 2.2 Term Index")]),t._v(" "),a("p",[t._v("Term Index 作为 Term Dictionary 的索引，"),a("strong",[t._v("资源消耗小，可以缓存在内存中，并且数据查找的复杂度低")]),t._v("。在讨论 Term Index 如何实现前，先来看看下面几个词语：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("coach、cottage\ndock、domain\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[t._v("这两组词汇分别具有共同的前缀：co 和 do。通过将Term Dictionary中的Term排序并按照公共前缀分块存储，而"),a("strong",[t._v("Term Index仅使用公共前缀进行索引")]),t._v("，从而将原本需要存储coach和cottage两个字符串的索引，简化为只需存储co一个字符串的索引。这种设计使得具有相同公共前缀的Term在存储时能够节省空间，同时在查找操作时的复杂度为公共前缀长度：O(len(prefix))。")]),t._v(" "),a("p",[t._v("然而，这种索引设计也存在一个缺点，即它仅能够定位到共同前缀所在的块的位置，因此无法判断特定Term是否存在，也无法知道该Term在Term Dictionary（.tim）文件中的具体位置。\n"),a("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/elasticsearch/202311042127387.png",alt:"image.png"}}),t._v('\n在上述图示中，我们探讨了如何在每个块中快速查找对应的Term，这可以通过使用二分搜索方法来实现，因为块中的数据是有序的。然而，由于前缀已经在Term Index中保存，块中无需为每个Term再单独保存前缀信息，因此块中保存的每个Term都可以省略其前缀。以示例中的情况为例，以"co"前缀为例的块1中，保存的内容可简化为"ach"和"ttage"。这种优化设计进一步减少了存储空间的开销。')]),t._v(" "),a("p",[a("strong",[t._v("对于前缀索引的实现，业界通常使用 FST 算法来解决")]),t._v("。FST（Finite State Transducers）是一种 FSM（Finite State Machines，有限状态机），并且有着类似于 Trie 树的结构。下面来简单了解一下 FST。")]),t._v(" "),a("p",[t._v("FST 有以下的特点：")]),t._v(" "),a("ul",[a("li",[t._v("通过对 Term Dictionary 数据的前缀复用，压缩了存储空间；")]),t._v(" "),a("li",[t._v("高效的查询性能，O(len(prefix))的复杂度；")]),t._v(" "),a("li",[t._v("构建后不可变。（事实上，倒排索引一旦生成就不可变了。）")])]),t._v(" "),a("p",[t._v("下面是一个简化的 FST 图，从图中可以清晰地看出每条边都有两个元素：label 和 out。其中，label 对应于键的元素，比如对于键 cat，有 c、a、t 这三个元素，而 out 表示着边的值 value。每个小圆圈代表着 FST 的一个节点，这些节点可以分为两类——普通节点和 Final 节点。在图中，灰黑色的节点表示 Final 节点，而每个 Final 节点还有一个 Finalout 值，表示着该 Final 节点的值。\n"),a("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/elasticsearch/202311042127260.png",alt:"image.png"}})]),t._v(" "),a("p",[t._v("当访问 cat 的时候，读取 c、a、t 的值作和， 再加上 Final 节点的 Finalout 值即可：10 + 0 + 5 + 0 = 15；当访问 dog 的时候，读取 d、o、g 的值即可，但是由于 g 为 Final，所以需要加上 g 的 Finalout：1 + 0 + 0 + 1 = 2。")]),t._v(" "),a("p",[t._v("事实上，FST 是一种非常复杂的结构，可以把它理解为一个"),a("strong",[t._v("占用空间小且高效的 Key-Value 数据结构")]),t._v("。Term Index 使用 FST 做实现带来了两个基本功能：")]),t._v(" "),a("ul",[a("li",[t._v("快速试错，如果在 FST 上不存在，不需要再遍历整个 Term Dictionary；")]),t._v(" "),a("li",[t._v("快速定位到 Block 的位置，经过 FST 的输出，可以算出 Block 在文件中的位置。")])]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"_2-3-term-dictionary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-term-dictionary"}},[t._v("#")]),t._v(" 2.3 Term Dictionary")]),t._v(" "),a("p",[t._v("在构建倒排索引的三个组成部分中，Term Dictionary 起着关键作用，它维护着 Term 与 Posting List 之间的关系，并存储了丰富的 Term 相关信息。这包括记录了包含特定 Term 的文档数量（DocFreq）、Term 在整个段（Segment）中的出现频率等重要信息，同时也存储了指向 Posting List 文件的指针，指明文档 ID 列表的位置以及词频信息的位置等关键数据。")]),t._v(" "),a("p",[t._v("以如下图为例，在构建 Term Dictionary 的索引时，首先对所有 Term 进行排序。然后，将在 Term Dictionary 中具有相同前缀的 Term 分组，并以块的形式进行存储。对这些共同前缀进行索引，通过索引可以快速定位到 Term Dictionary 文件中公共前缀对应的块的偏移地址。这种有序的组织方式极大地提高了检索效率和存储紧凑性。\n"),a("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/elasticsearch/202311042128270.png",alt:"image.png"}}),t._v("\n因为每个块都具有相同的共同前缀，所以无需再存储每个 Term 的完整内容，仅需保留它们的后缀即可。此外，这些后缀都已经按顺序排列好。\n"),a("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/elasticsearch/202311042128341.png",alt:"image.png"}}),t._v("\n到此，我们能够通过 Term Index 和 Term Dictionary 迅速判定某个 Term 是否存在，而且在存在时，还能迅速地定位到相应的 Posting List 信息。")]),t._v(" "),a("hr"),t._v(" "),a("h3",{attrs:{id:"_2-4-posting-list"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-posting-list"}},[t._v("#")]),t._v(" 2.4 Posting List")]),t._v(" "),a("p",[t._v("Posting List 包含的内容远不止文档的 ID，实际上涵盖了更多信息，包括文档 ID、词频、以及位置等重要数据。Lucene 将这些数据分散保存在三个文件中，以便高效地管理和存储：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v(".doc")]),t._v(" 文件：其中记录了文档 ID 和 Term 的词频信息，而且还特别记录了跳表的细节，以加速文档 ID 的查询。此外，该文件还存储了 Term 在位置和偏移等文件（"),a("code",[t._v(".pos")]),t._v(" 和 "),a("code",[t._v(".pay")]),t._v("）中的具体位置信息，以便快速读取。")]),t._v(" "),a("li",[a("code",[t._v(".pay")]),t._v(" 文件：在该文件中，Payload 信息和 Term 在 "),a("code",[t._v(".doc")]),t._v(" 文件中的偏移信息得以记录。")]),t._v(" "),a("li",[a("code",[t._v(".pos")]),t._v(" 文件：这个文件则记录了 Term 在 "),a("code",[t._v(".doc")]),t._v(" 文件中的具体位置信息。")])]),t._v(" "),a("p",[t._v("然而，由于倒排索引的核心目标是寻找文档 ID，以下将主要关注文档 ID 的相关信息。在处理 Posting List 时，主要面临两大挑战：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("存储空间优化")]),t._v("：为了高效使用存储资源，必须对数据进行压缩存储。这涉及到如何在有限的空间中保存尽可能多的信息。")]),t._v(" "),a("li",[a("strong",[t._v("高效交集运算")]),t._v("：在搜索场景中，经常需要对多个 Posting List 进行交集运算。为了实现这一点，业界采用了跳表、Roaring Bitmaps 等高效的技术手段。")])]),t._v(" "),a("p",[t._v("因此，倒排索引中的 Posting List 不仅涵盖多样的数据，还需要在存储和处理上克服一系列的挑战。")]),t._v(" "),a("hr"),t._v(" "),a("h4",{attrs:{id:"_2-4-1-节省存储-整型压缩"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-1-节省存储-整型压缩"}},[t._v("#")]),t._v(" 2.4.1 节省存储：整型压缩")]),t._v(" "),a("p",[t._v("实际上，对于 Int 类型或者 Long 类型的数据，是可以进行压缩的。我们可以根据数据的取值范围来选择适当占用更小字节数的数据类型来存储原数据。以下是一个例子，展示了如何对 Int 数组进行压缩：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("## Int数组\n[8, 12, 100, 140]\n\n## 各个元素与其二进制表示\n8 -> 00001000\n12 -> 00001100\n100 -> 01100100\n140 -> 10001100\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])]),a("p",[t._v("对于这个整数数组，如果每个数据都需要用 4 个字节来存储，那么总共需要 16 个字节。然而，由于数组中最大的数只需 8 位（一个字节）即可表示，因此原本需要 16 个字节的数据现在仅需 4 个字节即可完成表示。")]),t._v(" "),a("p",[t._v("这就是"),a("strong",[t._v("整数压缩")]),t._v("的基本思路。当然，还有其他的方法（如后面介绍的 VIntBlock），但其核心思想都是"),a("strong",[t._v("以最小的位数表示原数据，同时保持数据读取的效率")]),t._v("。在 Lucene 中，Posting List 使用了两种编码格式来压缩整数类型的数据：PackedBlock 和 VIntBlock。此外，Lucene 在对整数进行压缩的基础上，还采用了差值存储的方式对文档 ID 进行进一步压缩处理，以实现更高程度的数据压缩。")]),t._v(" "),a("hr"),t._v(" "),a("h5",{attrs:{id:"_1-packedblock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-packedblock"}},[t._v("#")]),t._v(" 1）PackedBlock")]),t._v(" "),a("p",[t._v("在 Lucene 中，每处理完包含特定 Term 的 128 个文档时，会使用 PackedInts 进行压缩存储文档的 ID 和词频，从而生成一个 PackedBlock。PackedBlock 包含两个数组，一个用于存储文档的 ID，另一个用于存储词频。因此，"),a("strong",[t._v("PackedBlock 是一种用于存储固定长度整型数组的数据结构，其中数组的长度为 128。")])]),t._v(" "),a("p",[t._v("下面简要介绍一下 PackedInts 的实现原理。PackedInts 将一个 Int[] 数组压缩成一个 Block，压缩的方式是根据数组中最大的数的有效位数进行打包。具体来说，数组中的每个元素都按照最大数的有效位数来进行压缩。举个例子，考虑以下数组：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("## Int数组\n[8, 12, 100, 120]\n\n## 各个元素与其二进制表示\n8 -> 0001000\n12 -> 0001100\n100 -> 1100100\n120 -> 1111000\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])]),a("p",[t._v("最大值为 120 的有效位数为 7 位，因此数组中的所有数据都可以使用 7 位来表示。假设这个数组共有 128 个元素，并且最大值为 120，那么经过压缩后的数组如下所示：\n"),a("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/elasticsearch/202311042128708.png",alt:"image.png"}}),t._v("\n最终，这个数组占用的位数为 7 位 * 128 = 896 位 = 112 字节（此处未计入 len 占用的空间，但请注意，len 也需要花费空间进行存储）。与原始数据相比，即 128 * 4 字节 = 512 字节，这实际上节省了相当可观的空间。")]),t._v(" "),a("p",[t._v("PackedBlock仅适用于固定长度的数组数据存储。然而，若一个段（Segment）的文档数量不是 128 的整数倍，会出现如何处理的情况？这时，可以运用 VIntBlock 来进行存储。")]),t._v(" "),a("hr"),t._v(" "),a("h5",{attrs:{id:"_2-vintblock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-vintblock"}},[t._v("#")]),t._v(" 2）VIntBlock")]),t._v(" "),a("p",[t._v("VIntBlock 使用变长整型编码方式来高效地对数据进行压缩，因此能够灵活地存储多样的数据类型，摆脱了需要事先规定数据元素位数的束缚，与 PackedInts 不同。VIntBlock 利用可变长度的字节序列对整数进行压缩，具体来说，VInt 使用可变长度的字节来表达一个整数，每个字节的 1 到 7 位用来存储数据，而第 8 位则作为是否需要读取下一个字节的标志位，实现了数据的高效压缩与存储。\n"),a("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/elasticsearch/202311042129858.png",alt:"image.png"}}),t._v("\n如上图，本身 Int 200 需要 4 个字节来进行存储，使用 VInt 后只需要 2 个字节即可。")]),t._v(" "),a("hr"),t._v(" "),a("h5",{attrs:{id:"_3-使用packedblock-vintblock来解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-使用packedblock-vintblock来解析"}},[t._v("#")]),t._v(" 3）使用PackedBlock&VIntBlock来解析")]),t._v(" "),a("p",[t._v("在处理文档时，Lucene采取了一种策略：每处理128篇文档，将相应的文档ID数组（docDeltaBuffer）和词频（TermFreq）数组（freqBuffer）转化为两个块：PackedDocDeltaBlock和PackedFreqBlock。这些数据通过使用PackedInts类进行高效的压缩存储，生成一个PackedBlock。对于不足128篇文档的情况，Lucene采用VIntBlock进行存储（例如，如果有131个文档，则会生成一个PackedBlock和3个VIntBlock）。同时，在生成PackedBlock时，Lucene还会创建一个跳表（SkipData），以便在读取数据时能够快速跳转到指定的PackedBlock，从而提升读取效率。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/elasticsearch/202311042129139.png",alt:"image.png"}})]),t._v(" "),a("hr"),t._v(" "),a("h5",{attrs:{id:"_4-使用文档id差值存储来节省空间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-使用文档id差值存储来节省空间"}},[t._v("#")]),t._v(" 4）使用文档ID差值存储来节省空间")]),t._v(" "),a("p",[t._v("通过对整数进行压缩，我们能够有效减少单个数值所占用的空间。更为巧妙的是，正整数之间存在着一个微妙的关系："),a("strong",[t._v("两个正整数之间的差值一定小于它们中较大的那个数。")])]),t._v(" "),a("p",[t._v("利用这一特性，我们能够将需要压缩的整数变为更小的数，进一步降低存储空间的占用。由于文档 ID 数组是按顺序排列的，因此在保存文档 ID 时，我们不直接存储文档的 ID，而是存储与前一个文档 ID 的差值。这一策略能够进一步压缩存储空间，达到更高的空间利用效率！")]),t._v(" "),a("blockquote",[a("p",[t._v("词频是无序的，无法使用下面的处理方式。")])]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("ids = [1, 4, 6, 9, 14, 17, 21, 25]\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("如上面给定的数组 ids，如果用 PackedInts 的方式来对数据进行压缩的话，那么25（0001 1001）最少需要用 5 bit 来存储，所以整个数组需要 5 * 8 = 40 bit 来存储。如果数组中存储的是文档 ID 的差值，那么这个差值数组如下：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("dtIds = [1, 3, 2, 3, 5, 3, 4, 4]\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("dtIds 数组中最大值为 5（0000 0101），其最少需要 3 bit 来表示，那么整个数组只需要 3 * 8 = 24 bit，相对于原来需要 40 bit 来存储数据，差值存储的方式可以有效降低存储的空间。"),a("strong",[t._v("两个正整数间的差值会比它们间最大的那个要小，所以需要的有效位数就可能会减少。")])]),t._v(" "),a("p",[t._v("其实综合了上面所有的流程，无非就是文档 ID 使用增量编码，数据分块存储、数据按需分配存储空间，而"),a("strong",[t._v("这整个过程叫做 FOR（Frame Of Reference）")]),t._v(" 。")]),t._v(" "),a("hr"),t._v(" "),a("h4",{attrs:{id:"_2-4-2-文档id列表的交集求解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-2-文档id列表的交集求解"}},[t._v("#")]),t._v(" 2.4.2 文档ID列表的交集求解")]),t._v(" "),a("p",[t._v("如果您希望检索书名为《躺平是怎样练成的》、作者姓张，且书中包含词语“摆烂”的书籍，系统将返回三条包含相应文档 ID 的列表，如下图所示：\n"),a("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/elasticsearch/202311042129168.png",alt:"image.png"}}),t._v("\n如果直接循环 3 个数组求交集，并不是很高效，下面对其进行优化。")]),t._v(" "),a("hr"),t._v(" "),a("h5",{attrs:{id:"_1-位图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-位图"}},[t._v("#")]),t._v(" 1）位图")]),t._v(" "),a("p",[t._v("如果将列表的数据改造成位图会如何？假如有两个 posting list A 、B 和它们生成的位图如下：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("A = [2, 3, 5] => BitmapA = [0, 0, 1, 1, 0, 1]\nB = [1, 2, 5] => BitmapB = [0, 1, 1, 0, 0, 1]\n\nBitmapA AND BitmapB = [0, 0, 1, 0, 0, 1]\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/elasticsearch/202311042130950.png",alt:"image.png"}})]),t._v(" "),a("p",[t._v("生成位图的方法非常简单：对于每个元素A[i]，将Bitmap[A[i]]设置为1，其他位置设置为0。这样，我们可以直接对两个位图A和B进行AND位运算，因为位图的长度是固定的，所以AND运算的复杂度也是恒定的。由于CPU执行位运算的效率非常高，因此在位图相对较小的情况下，使用位图求交集是非常高效的。")]),t._v(" "),a("p",[t._v("然而，位图也存在其致命的弱点，这些弱点可以总结如下：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("潜在的高空间消耗：")]),t._v(" 尽管位图仅需要 1 位来表示相应元素的存在与否，但在某些情况下可能消耗大量的空间。特别是当列表中存在非常大的元素范围时，例如数组 [1, 65535]，表示它需要 65535 位。使用 int32 类型的数组表示，一个位图就需要 512MB 的存储空间（2^32 bit = 2^29 Byte = 512MB）。如果存在 N 个这样的位图，存储开销将达到 N * 512MB，这种空间消耗可能是相当可观的。")]),t._v(" "),a("li",[a("strong",[t._v("适用于数据密集的场景：")]),t._v(" 位图更适合处理数据相对密集的情况，对于数据分布较为稀疏的情况，位图可能不是最优选择。")]),t._v(" "),a("li",[a("strong",[t._v("仅适用于简单整型数据：")]),t._v(" 位图主要适用于存储简单的整型数据。对于复杂的对象类型，位图无法进行处理，或者说复杂类型本身无法直接在 CPU 上执行 AND 这样的位操作符。")])]),t._v(" "),a("p",[t._v("在实际应用中，为了克服位图可能带来的空间消耗问题，业界采用了一项名为 Roaring Bitmap 的压缩位图技术。Roaring Bitmap 在许多领域得到了广泛的应用，接下来我们将深入了解 Roaring Bitmap 的实现原理。")]),t._v(" "),a("hr"),t._v(" "),a("h5",{attrs:{id:"_2-roaring-bitmaps"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-roaring-bitmaps"}},[t._v("#")]),t._v(" 2）Roaring Bitmaps")]),t._v(" "),a("p",[t._v("Roaring Bitmaps将一个32位的整数划分为两个部分：高16位和低16位。高16位被当作一个数值存储在有序数组中，这个数组的每个元素表示一个块。而低16位则被存储在一个2^16的位图中，位图的对应位置被设置为1。这样，每个块都与一个位图相对应，如下图所示：\n"),a("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/elasticsearch/202311042130025.png",alt:"image.png"}}),t._v(" "),a("strong",[t._v("Roaring Bitmaps以有序数组与位图(Bitmap)的组合形式，将数据拆分为按需分配的有序数组，以此来有效节省存储空间")]),t._v("。在Roaring Bitmaps中，一个位图(Bitmap)最多包含2^16个位(bit)，总计占用8K的存储空间。而由于块中存储的是整数，每个整数只需2个字节存储。考虑到块中最多有2^16个整数，因此有序数组最大需占用128K的存储空间。由于有序数组的存储是按需分配的，Roaring Bitmaps的实际存储空间由数据量决定，而位图的存储空间则由其中最大的整数决定。以一个范例来说明，对于数组[0, 2^32 - 1]，使用位图存储需要512M的空间，而Roaring Bitmaps仅需2 * (2 Byte + 8K)的空间。")]),t._v(" "),a("p",[t._v("由于Roaring Bitmaps由有序数组与位图构成，因此要判断一个数是否存在于Roaring Bitmaps中，需要进行两次查询。首先，使用二分查找在有序数组中根据高16位进行查询，其时间复杂度为O(log n)；若存在，则再在对应的位图(Bitmap)中查找低16位，判断相应位置是否为1，这一步的复杂度为O(1)。因此，"),a("strong",[t._v("Roaring Bitmaps不仅可以节省空间，还具备高效的检索能力")]),t._v("。")]),t._v(" "),a("p",[t._v("不过，如果每个块的位图一直占用8K的存储空间，是否会造成严重浪费呢？若某一块的数据较少或较稀疏，也许使用数组会更合适。那么，使用数组还是位图，应该在什么阈值下做选择呢？当数据量达到4096时，我们发现4096 * 16位（2字节）= 8K，因此当一个块的数据量小于4096时，可以使用短整型（short）类型的有序数组来存储数据，同时采用变长数组进一步节省存储空间。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/elasticsearch/202311042130737.png",alt:"image.png"}})]),t._v(" "),a("p",[t._v("业界除了使用 Roaring Bitmaps 来求交集外，还使用了跳表。")]),t._v(" "),a("hr"),t._v(" "),a("h5",{attrs:{id:"_3-使用跳表加速多个列表交集的求解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-使用跳表加速多个列表交集的求解"}},[t._v("#")]),t._v(" 3）使用跳表加速多个列表交集的求解")]),t._v(" "),a("p",[t._v("跳表是一种有序的数据结构，它"),a("strong",[t._v("通过在每个节点中维持多个指向其他节点的索引，从而达到快速访问的目的")]),t._v("。\n跳表具有以下特点：")]),t._v(" "),a("ol",[a("li",[t._v("元素按照顺序排列，从小到大。")]),t._v(" "),a("li",[t._v("跳跃是具有间隔的，即同一层级两个相邻的跳表节点，间隔一致，间隔是预先定义好的。")]),t._v(" "),a("li",[t._v("跳表是具有层级的，除底层原链表外，上层链表每隔指定间隔数量底层节点，创建一个上层节点，如下图中，层级为2。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/elasticsearch/202311042130085.png",alt:"image.png"}}),t._v("\n如上图，有序链表不能像有序数组那样使用二分法进行快速访问，但可以对有序链表维护一层或者多层索引使其快速访问。")]),t._v(" "),a("p",[t._v("在求解两个有序列表 A 和 B 的交集时，可以使用归并排序的方法来遍历两个列表，将复杂度从 O(M * N) 降低到 O(M + N)，这里的 M、N 分别为这两个列表的长度。")]),t._v(" "),a("p",[t._v("链表归并求交集的过程可以总结为以下三个步骤。")]),t._v(" "),a("ul",[a("li",[t._v("第一步：将指针 p1 和 p2 分别指向列表 A 和 B 的开头。")]),t._v(" "),a("li",[t._v("第二步：比较 p1 和 p2 指向的数据，会出现 3 种情况，如果内容相等，说明是公共元素，需要加入到结果集中；如果 p1 的内容小于 p2 的内容，p1 向后移；如果 p1 的内容大于 p2 的内容，p2 向后移。总结起来就是，"),a("strong",[t._v("谁小谁就往前走，相等就一起往前走，直到有一方结束")]),t._v("！")]),t._v(" "),a("li",[t._v("第三步：重复第二步，直到 p1 或者 p2 到达链表尾为止。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/elasticsearch/202311042131613.jpeg",alt:"未命名文件.jpg"}})]),t._v(" "),a("p",[t._v("归并排序的方式可以降低链表求交集的复杂度，但上述的算法还有优化的地方。\n"),a("img",{attrs:{src:"https://raw.githubusercontent.com/huidongyin/DrawingBed/main/elasticsearch/202311042131822.jpeg",alt:"使用跳表优化链表取交集.jpg"}})]),t._v(" "),a("hr")])}),[],!1,null,null,null);a.default=s.exports}}]);